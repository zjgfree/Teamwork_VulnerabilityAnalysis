import re
from data_module.db_access import *


def fc_matcher(node, node_dict):
    obj = node_dict[node]
    return obj["_label"] == "CALL" and obj["name"] in fc_matcher.sensitive_func


fc_matcher.sensitive_func = load_from_pickle(f"./syvc_module/sensitive_func.db")


def array_matcher(node, node_dict, ast):
    """ 数组筛选：下标不是常数时才考虑 """
    obj = node_dict[node]
    return (
        obj["_label"] == "CALL" 
        and obj["methodFullName"] == "<operator>.indirectIndexAccess"
        and any(node_dict[sub]["_label"] == "IDENTIFIER" for sub in  ast.get_sub_ast(ast.edge_dict.get(node, [])[-1], node_dict))
    )

def pointer_matcher(node, node_dict, ast):
    """
    指针越界
    考虑：p+-len, p+-=len的情况，其中p为指针
    判断：为加减或assignmentPlus/Minus，左为指针。
    关键变量：p和len
    """
    obj = node_dict[node]
    child = ast.edge_dict.get(node, [])
    if (
        obj["_label"] == "CALL"
        and obj["methodFullName"] in ["<operator>.addition", "<operator>.subtraction", "<operator>.assignmentPlus", "<operator>.assignmentMinus"]
        and "*" in node_dict[child[0]]["typeFullName"]
    ):
        return True
    return False

def integerOverflow(node, node_dict, ae_flag, ast):
    """整数溢出：原名ae_matcher"""
    obj = node_dict[node]
    child = ast.edge_dict.get(node, [])
    sub_ast = ast.get_sub_ast(node, node_dict, blk_flag=True)
    return (
        not ae_flag
        and obj["_label"] == "CALL"
        and (
            # 乘除左移的情况：直接考虑，因为一般只有int才会进行这种运算。
            obj["methodFullName"] in integerOverflow.ae_func_1
            # 对加减的情况：左侧操作数为int或无法判断类型，且将 a+=2 类似的情况去除，因为这种太多且很少有漏洞。2的标签为"Literal"
            or obj["methodFullName"] in integerOverflow.ae_func_2
            and node_dict[child[0]]["typeFullName"] in int_types
            and len( [ v for v in sub_ast if node_dict[v]["_label"] == "IDENTIFIER" ]) >= 2
        )
    )


integerOverflow.ae_func_1 = {
    "<operator>.multiplication",
    "<operator>.division",
    "<operator>.shiftLeft",
    "<operator>.assignmentMultiplication",
    "<operator>.assignmentDivision",
    "<operators>.assignmentShiftLeft",  # 后期名称可能改正
}

integerOverflow.ae_func_2 = {
    "<operator>.subtraction",
    "<operator>.addition",
    "<operator>.assignmentMinus",
    "<operator>.assignmentPlus",
}

# unsigned 在类型的前还是后，这通过具体例子确定，挺奇怪的
int_types = {
    "char", "unsigned char","char unsigned"
    "short", "unsigned short", "short unsigned",
    "int", "unsigned int", "int unsigned",
    "long", "unsigned long", "long unsigned",
    "long long", "unsigned long long", "long long unsigned",
    "<empty>"
}

def NPD_matcher(node, node_dict, def_flag):
    """CWE-476 NULL Pointer Dereference 空指针解引用"""
    obj = node_dict[node]
    return (
        obj["_label"] == "CALL"
        and obj["methodFullName"] == "<operator>.indirectFieldAccess"
        and "->" in obj["code"] # 如out->desc
        # 还应该增加：在前面是否对out进行过非空判断
    )

def pathTraversal_matcher(node, node_dict, def_flag):
    """CWE-22 路径函数：通过关键字匹配"""
    obj = node_dict[node]
    key_list = [
        "open", "read", "mkdir", "append", "setPorperty"
    ]
    if obj["_label"] == "CALL":
        for key in key_list:
            if key in obj["methodFullName"]:
                return True
    return False

def divideByZero_matcher(node, node_dict, ast):
    """CWE-369 divide-by-zero error"""
    obj = node_dict[node]
    key_list = [
        "<operator>.division", "<operator>.assignmentDivision", "<operator>.modulo", "<operators>.assignmentModulo", "DIV"
    ]
    if obj["_label"] == "CALL" and obj["methodFullName"] in key_list:
        # 分母中有子节点包含标识符（也就是变量）：排除全是常量的情况
        if any(node_dict[sub]["_label"] == "IDENTIFIER" for sub in  ast.get_sub_ast(ast.edge_dict.get(node, [])[-1], node_dict)):
            return True
    return False

def assert_matcher(node, node_dict, def_flag):
    '''CWE-617 可达断言匹配, 通过关键字匹配'''
    obj = node_dict[node]
    key_list = [
        "assert", "BUG", "OVS_NOT_REACHED", "validate_as_request"
    ]
    if obj["_label"] == "CALL":
        for key in key_list:
            if key in obj["methodFullName"]:
                return True
    return False

def free_matcher(node,node_dict):
    '''CWE-415,CWE-416 UAF与DoubleFree'''
    obj = node_dict[node]
    key_list = ['free','delete','realloc','unregister','Destroy','close', 'RELEASE']
    if obj["_label"] == "CALL":
        for key in key_list:
            if key in obj["methodFullName"]:
                return True
    return False

# def InfiniteLoop_matcher(node, node_dict):
#     """
#     CWE-835 无限循环匹配
#     搜寻代码中是否存在关键字 while, do-while, for 和 goto，或者是否存在函数的递归调用
#     参数:
#         node (dict): 节点数据
#         node_dict (dict): 包含所有节点的字典
#     返回:
#         bool: 如果存在无限循环，则为 True，否则为 False
#     """
#     obj = node_dict[node]
#     if obj["_label"] in ["IterWhileStmt", "DoStmt", "IterForStmt"]:
#         return True
#     if obj["_label"] == "CALL" and obj["name"] == obj["methodFullName"]:
#         return True
#     return False