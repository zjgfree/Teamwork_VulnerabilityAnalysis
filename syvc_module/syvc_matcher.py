import re
from data_module.db_access import *


def fc_matcher(node, node_dict):
    obj = node_dict[node]
    return obj["_label"] == "CALL" and obj["name"] in fc_matcher.sensitive_func


fc_matcher.sensitive_func = load_from_pickle(f"./syvc_module/sensitive_func.db")


def array_matcher(node, node_dict, def_flag):
    """数组筛选"""
    obj = node_dict[node]
    if obj["_label"] == "METHOD_PARAMETER_IN":
        return "[" in obj["typeFullName"]
    return (
        def_flag
        and obj["_label"] == "CALL"
        and obj["methodFullName"] == "<operator>.indirectIndexAccess"
    )



def pointer_matcher(node, node_dict, def_flag):
    """指针越界"""
    obj = node_dict[node]
    if obj["_label"] == "METHOD_PARAMETER_IN":
        return "*" in obj["typeFullName"]
    return (
        def_flag
        and obj["_label"] == "IDENTIFIER"
        and obj["refto"] != "LOST"
        and "*" in node_dict[obj["refto"]]["code"]
    )


def integerOverflow(node, node_dict, ae_flag, ast):
    """整数溢出：原名ae_matcher"""
    obj = node_dict[node]
    return (
        not ae_flag
        and obj["_label"] == "CALL"
        and (
            obj["methodFullName"] in integerOverflow.ae_func_1
            or obj["methodFullName"] in integerOverflow.ae_func_2
            and len(
                [
                    v
                    for v in ast.get_sub_ast(node, node_dict, blk_flag=True)
                    if node_dict[v]["_label"] == "IDENTIFIER"
                ]
            )
            >= 2
        )
    )


integerOverflow.ae_func_1 = {
    "<operator>.multiplication",
    "<operator>.division",
    "<operator>.shiftLeft",
    "<operator>.assignmentMultiplication",
    "<operator>.assignmentDivision",
    "<operators>.assignmentShiftLeft",  # 后期名称可能改正
}

integerOverflow.ae_func_2 = {
    "<operator>.subtraction",
    "<operator>.addition",
    "<operator>.assignmentMinus",
    "<operator>.assignmentPlus",
}

def NPD_matcher(node, node_dict, def_flag):
    """CWE-476 NULL Pointer Dereference 空指针解引用"""
    obj = node_dict[node]
    return (
        obj["_label"] == "CALL"
        and obj["methodFullName"] == "<operator>.indirectFieldAccess"
        and "->" in obj["code"] # 如out->desc
        # 还应该增加：在前面是否对out进行过非空判断
    )

def pathTraversal_matcher(node, node_dict, def_flag):
    """CWE-22 路径函数：通过关键字匹配"""
    obj = node_dict[node]
    key_dict = [
        "open", "read", "mkdir", "append", "setPorperty"
    ]
    if obj["_label"] == "CALL":
        for key in key_dict:
            if key in obj["methodFullName"]:
                return True
    return False

def divideByZero_matcher(node, node_dict, def_flag):
    """CWE-369 divide-by-zero error"""
    obj = node_dict[node]
    key_dict = [
        "<operator>.division", "<operator>.assignmentDivision", "<operator>.modulo", "<operators>.assignmentModulo", "DIV", "alloc"
    ]
    if obj["_label"] == "CALL":
        for key in key_dict:
            if key in obj["methodFullName"]:
                return True
    return False

def assert_matcher(node, node_dict, def_flag):
    '''CWE-617 可达断言匹配, 通过关键字匹配'''
    obj = node_dict[node]
    key_dict = [
        "assert", "BUG", "OVS_NOT_REACHED", "validate_as_request"
    ]
    if obj["_label"] == "CALL":
        for key in key_dict:
            if key in obj["methodFullName"]:
                return True
    return False

def free_matcher(node,node_dict):
    '''CWE-415,CWE-416 UAF与DoubleFree'''
    obj = node_dict[node]
    s = ['free','delete','realloc','unregister','Destroy','close']
    for str_s in s:
        if str_s in obj['code']:
            return True
    return False
##########################################################################
'''
·本文件CWE_835.py主要功能：
    通过Joern对代码文件分析所获得的初步信息node,node_dict等,
    不通过切片的方式,直接读取node以及node_dict中的信息,
    从而判断是否存在CWE-835无限循环漏洞

·所采用的主要方法：
    1. 对于while/for/do_while类型的循环,判断循环体中是否有针对循环控制变量的显性修改;
    (显性修改此处的定义为“增量修改”，而将“赋值修改”，“条件控制修改”，“跳转修改”等修改方式定义为隐性修改)
    ,若存在while(1)这类语句，直接判定其为无限循环漏洞
    2. 对于由递归不当所造成的无限循环漏洞，直接判定一个函数体中是否调用函数本身实现粗略判断;

·未实现的功能：
    CWE-835中,由于goto语句执行不当所造成的无限循环漏洞未能实现准确判断
'''


def InfiniteLoop_matcher(node, node_dict):
    """
    CWE-835 无限循环匹配 判断while循环、for循环、do-while循环中是否有对循环控制变量进行增量修改操作
    对于goto/递归函数调用，仅进行了最基础的判断 

    Args:
        node:       经joern分析得出循环节点
        node_dict:  节点字典

    Returns:
        bool: True表示存在对循环控制变量的增量修改操作，False表示不存在
    """
    label = node_dict[node]["_label"]

    if label == "WHILE":
        # 获取while循环的条件节点
        condition_id = node_dict[node]["children"][0]
        condition = node_dict[condition_id]
        # 从条件中提取循环控制变量
        loop_control_variable = get_variable_from_condition(condition, node_dict)
        if loop_control_variable:
            # 判断条件是否为对变量的增量修改操作
            if is_increment_operation(condition, loop_control_variable, node_dict):
                return True
    if label == "FOR":
        # 获取for循环的初始化节点
        init_id = node_dict[node]["children"][0]
        init = node_dict[init_id]
        # 从初始化中提取循环控制变量
        loop_control_variable = get_variable_from_init(init, node_dict)
        if loop_control_variable:
            # 判断初始化是否为对变量的增量修改操作
            if is_increment_operation(init, loop_control_variable, node_dict):
                return True
    if label == "DO_WHILE":
        # 获取do-while循环的循环体节点
        body_id = node_dict[node]["children"][0]
        body = node_dict[body_id]
        # 从循环体中提取循环控制变量
        loop_control_variable = get_variable_from_body(body, node_dict)
        if loop_control_variable:
            # 判断循环体是否为对变量的增量修改操作
            if is_increment_operation(body, loop_control_variable, node_dict):
                return True
            
    '''暂时没有很好的想法'''
    if label == "GOTO":
        # 匹配goto造成的无限循环
        return True

    if label == "CALL":
    # 匹配递归函数调用情况
        function_name = node_dict[node]["name"]
        function_code = node_dict[function_name]["code"]
        # 在函数代码体中查找是否存在相同名称的函数调用
        if any(call_node["name"] == function_name and call_node["_label"] == "CALL" for call_node in function_code):
            return True

    return False


def get_variable_from_condition(condition, node_dict):
    """
    从条件表达式中提取循环控制变量

    Args:
        condition: 条件表达式节点
        node_dict: 节点字典

    Returns:
        str: 循环控制变量的名称，如果未找到则返回None
    """
    if condition.type == "ParenExpr":
        sub_expr_id = condition["children"][0]
        sub_expr = node_dict[sub_expr_id]
        return get_variable_from_condition(sub_expr, node_dict)
    elif condition.type == "BinaryOperator" and condition["op"] == "<=":
        left_operand_id = condition["children"][0]
        left_operand = node_dict[left_operand_id]
        if left_operand.type == "Identifier":
            return left_operand.name
    return None


def get_variable_from_init(init, node_dict):
    """
    从for循环的初始化表达式中提取循环控制变量

    Args:
        init: 初始化表达式节点
        node_dict: 节点字典

    Returns:
        str: 循环控制变量的名称，如果未找到则返回None
    """
    if init.type == "BinaryOperator" and init["op"] == "=":
        left_operand_id = init["children"][0]
        left_operand = node_dict[left_operand_id]
        if left_operand.type == "Identifier":
            return left_operand.name
    return None


def get_variable_from_body(body, node_dict):
    """
    从do-while循环的循环体中提取循环控制变量

    Args:
        body: 循环体节点
        node_dict: 节点字典

    Returns:
        str: 循环控制变量的名称，如果未找到则返回None
    """
    if body.type == "CompoundStmt":
        stmts = body["children"]
        for stmt_id in stmts:
            stmt = node_dict[stmt_id]
            if stmt.type == "BinaryOperator" and stmt["op"] == "=":
                left_operand_id = stmt["children"][0]
                left_operand = node_dict[left_operand_id]
                if left_operand.type == "Identifier":
                    return left_operand.name
    return None


def is_increment_operation(condition, variable, node_dict):
    """
    判断条件表达式是否为对循环控制变量的增量修改操作

    Args:
        condition: 条件表达式节点
        variable: 循环控制变量的名称
        node_dict: 节点字典
    Returns:
        bool: True表示条件表达式为对循环控制变量的增量修改操作，False表示不是
    """
    if condition.type == "BinaryOperator" and condition["op"] in ("+=", "-=", "++", "--"):
        left_operand_id = condition["children"][0]
        left_operand = node_dict[left_operand_id]
        if left_operand.type == "Identifier" and left_operand.name == variable:
            return True
    return False
######################################################################################