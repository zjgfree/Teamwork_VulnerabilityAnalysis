import heapq, bisect
from typing import Dict
from config import db_path
from config import PREPARE_DEBUG, SLICE_ALL
from config import FDG_CTRL, BSLICE_TOPO, FSLICE_TOPO
from igraph import *

from data_module.db_access import dump_to_json
from .graph_patch import ast_patcher
from syvc_module import syvc_matcher


def get_edge_set(edge_dict_list, *, reverse=False):
    edge_set = set()
    for edge_dict in edge_dict_list:
        for source, t_list in edge_dict.items():
            [
                edge_set.add((target, source) if reverse else (source, target))
                for target in t_list
                if source != target
            ]
    return edge_set


class AST:
    def get_sub_ast(self, node, node_dict, blk_flag=False, *, fa=None):
        if not blk_flag and (
            node_dict[node]["_label"] == "BLOCK"
            or (
                fa is not None
                and node_dict[fa]["_label"] == "CONTROL_STRUCTURE"
                and node_dict[node]["order"] == len(self.edge_dict[fa])
            )
        ):
            return []

        sub_ast = [node]
        for ch in self.edge_dict.get(node, []):
            sub_ast.extend(self.get_sub_ast(ch, node_dict, blk_flag, fa=node))
        return sub_ast

    def get_slice_src(
        self,
        node: str,
        node_dict: Dict[str, Dict[str, str]],
        src_dict: Dict[str, set[str]],
        pdg_node,
        def_flag,
        ae_flag,
    ):
        if node_dict[node]["inpdg"]:
            pdg_node = node

        asgn_flag = (
            pdg_node == node
            and node_dict[node]["_label"] == "CALL"
            and "<operator>.assignment" in node_dict[node]["methodFullName"]
        )

        ae_flag &= not asgn_flag

        ADD_FLAG = SLICE_ALL

        if syvc_matcher.fc_matcher(node, node_dict):
            src_dict["FC"].add(pdg_node)
            ADD_FLAG = True
        if syvc_matcher.au_matcher(node, node_dict, def_flag):
            src_dict["AU"].add(pdg_node)
            ADD_FLAG = True
        if syvc_matcher.pu_matcher(node, node_dict, def_flag):
            src_dict["PU"].add(pdg_node)
            ADD_FLAG = True
        if syvc_matcher.ae_matcher(node, node_dict, ae_flag, self):
            src_dict["AE"].add(pdg_node)
            ADD_FLAG = ae_flag = True

        if ADD_FLAG:
            src_dict["ALL"].add(pdg_node)

        for ch in self.edge_dict.get(node, []):
            def_flag = node_dict[ch]["order"] == 1 if asgn_flag else def_flag
            self.get_slice_src(ch, node_dict, src_dict, pdg_node, def_flag, ae_flag)

    def __init__(self, proj, fid, edge_dict_list, node_dict):
        self.fid = fid
        self.proj = proj
        self.edge_dict = {}
        [
            self.edge_dict.setdefault(a, []).append(b)
            for a, b in get_edge_set(edge_dict_list)
        ]
        [
            self.edge_dict[v].sort(key=lambda x: node_dict[x]["order"])
            for v in self.edge_dict
        ]

        ast_patcher.patch_main(self, node_dict)
        self.fa_dict = {v: f for f in self.edge_dict for v in self.edge_dict[f]}
        self.fa_dict[fid] = None

        if PREPARE_DEBUG:
            dump_to_json(self.edge_dict, f"{db_path}/{proj}/ast_{fid}.json")


class XDG:
    # 该函数从目标节点开始切片，切片结果为当前节点下的所有节点的有序序列
    def slice(self, src, node_dict):
        pq = [(self.topo_rank[v], v) for v in src]      # 优先队列，前者为拓扑值，后者为节点id
        heapq.heapify(pq)       # 对优先队列进行堆化

        visited_node_set = set(src)
        no_dfs_node_set = set()
        slice_list = []

        last_v = pq[0][1]       # 优先队列的第一个节点

        while pq:
            node = heapq.heappop(pq)[1]             # 弹出优先队列第一个节点！！！
            to_list = self.edge_dict.get(node, [])  # to_list为node节点一步可以到达的节点列表！！！！！！！！！！！！！！！！
            slice_list.append(node)             # 加入切片结果列表！！！
            
            if node not in no_dfs_node_set:             # 对于没有进行过dfs的节点
                # 理解过程中可以不看下面这个if，这是一个优化，避免反复求同一组切片列表
                #
                #
                if (node,) in self.slice_data:          # 对于作为目标节点进行过切片的节点，
                    v_list = self.slice_data[(node,)]   # 获取其切片列表v_list
                    v_list = v_list[                    # 进行拓扑排序
                        bisect.bisect(
                            v_list,
                            last_v,
                            key=lambda x: self.topo_rank[x],
                        ) :
                    ]
                    for v in v_list:        # 将v_list中未经过的节点加入优先队列，更新no_dfs_node_set
                        if v not in visited_node_set:
                            heapq.heappush(pq, (self.topo_rank[v], v))
                            visited_node_set.add(v)
                        no_dfs_node_set.add(v)      

                    to_list = to_list[          # 对to_list中的元素进行拓扑排序
                        : bisect.bisect(
                            to_list,
                            last_v,
                            key=lambda x: self.topo_rank[x],
                        )
                    ]

                    if v_list:
                        last_v = v_list.pop()
                #
                #
                # 对于不在no_dfs_node_set中的节点，遍历to_list，按照拓扑顺序压入优先队列
                for v in to_list:           # ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
                    if v not in visited_node_set:
                        heapq.heappush(pq, (self.topo_rank[v], v))  # 未经过，则压入优先队列
                        visited_node_set.add(v)         # 更新已经过的节点集合
        # 拓扑排序与列表反转
        if not (FSLICE_TOPO, BSLICE_TOPO)[self.reverse]:
            slice_list.sort(
                key=lambda x: (
                    node_dict[self.cluster_list[x][0]]["lineNumber"],
                    node_dict[self.cluster_list[x][0]]["columnNumber"],
                ),
                reverse=self.reverse,
            )

        return slice_list

    def get_std_src(self, raw_src):
        return tuple(   # 以元组形式返回，具有不可变性
            sorted(     # 排序，依据为key，值为topo_rank[x]，这是提前设置好的一个拓扑排序
                {self.cluster_dict[v] for v in raw_src if v in self.cluster_dict},          # 虽然raw_src为列表，
                key=lambda x: self.topo_rank[x],                                            # 但当下我们只存入了一个关注点
            )
        )

    def compute_all_slice_data(self, src_list, node_dict):
        std_src_list = []
        for raw_src in src_list:
            std_src = self.get_std_src(raw_src)
            if std_src:
                std_src_list.append(std_src)

        for std_src in sorted(
            std_src_list,
            key=lambda x: self.topo_rank[x[0]],
            reverse=True,
        ):
            if std_src not in self.slice_data:
                self.slice_data[std_src] = self.slice(std_src, node_dict)

    def get_slice_data(self, raw_src, node_dict):
        std_src = self.get_std_src(raw_src)
        if not std_src:
            return []
        else:
            if std_src not in self.slice_data:
                self.slice_data[std_src] = self.slice(std_src, node_dict)   # 根据当前节点列表std_src，进行切片
            return self.slice_data[std_src]

    def topo_sort(self, node_dict):
        self.topo_list = []
        self.topo_rank = [None] * len(self.dag.vs)
        in_degree_list = self.dag.indegree()
        """在数据依赖边修复后，将下面修改为：
        stack = [self.cluster_dict[self.src]]
        """
        stack = [i for i, d in enumerate(in_degree_list) if not d]
        while stack:
            node = stack.pop()
            self.topo_list.append(node)
            target_list = sorted(
                self.dag.successors(node),
                key=lambda x: (
                    node_dict[self.cluster_list[x][0]]["lineNumber"],
                    node_dict[self.cluster_list[x][0]]["columnNumber"],
                ),
                reverse=not self.reverse,
            )

            # print(node, [self.cluster_list[v] for v in target_list])

            for target in target_list:
                in_degree_list[target] -= 1
                if not in_degree_list[target]:
                    stack.append(target)

        # assert not any(in_degree_list)

        for rank, node in enumerate(self.topo_list):
            self.topo_rank[node] = rank

    def __init__(
        self,
        proj,
        fid,
        src,
        edge_dict_list,
        node_dict,
        *,
        reverse=False,
    ) -> None:
        self.src = src
        self.fid = fid
        self.proj = proj
        self.reverse = reverse
        self.xdg = Graph.TupleList(
            get_edge_set(edge_dict_list, reverse=reverse), directed=True
        )
        c = self.xdg.clusters()
        self.cluster_list = [
            sorted(             # 根据代码行号与列号排序
                [self.xdg.vs[v]["name"] for v in node_list],
                key=lambda x: (
                    node_dict[x]["lineNumber"],
                    node_dict[x]["columnNumber"],
                ),
                reverse=self.reverse,       # 为True则反向
            )
            for node_list in c   # 遍历c的每个node_list           
        ]
        self.cluster_dict = {
            v: i for i, cluster in enumerate(self.cluster_list) for v in cluster
        }
        self.dag = c.cluster_graph()

        self.topo_sort(node_dict)

        self.edge_dict = {}
        [self.edge_dict.setdefault(e.source, []).append(e.target) for e in self.dag.es]
        [
            self.edge_dict[v].sort(key=lambda x: self.topo_rank[x])
            for v in self.edge_dict
        ]

        self.slice_data = {}

        if PREPARE_DEBUG:
            prefix_path = f"{db_path}/{proj}/{'fb'[reverse]}dg_{fid}"
            self.xdg.write_dot(f"{prefix_path}.dot")
            self.dag.write_dot(f"{prefix_path}_dag.dot")
            dump_to_json(self.cluster_dict, f"{prefix_path}_cluster_dict.json")
            dump_to_json(self.cluster_list, f"{prefix_path}_cluster_list.json")
            dump_to_json(self.topo_list, f"{prefix_path}_topo_list.json")
            dump_to_json(self.topo_rank, f"{prefix_path}_topo_rank.json")
            dump_to_json(self.edge_dict, f"{prefix_path}_edge_dict.json")


class GraphDB:
    def get_slice_src(self, node_dict):
        self.src_dict = {
            "ALL": set(),
            "AU": set(),
            "PU": set(),
            "AE": set(),
            "FC": set(),
        }
        self.ast.get_slice_src(self.fid, node_dict, self.src_dict, None, False, False)

    def get_bslice_data(self, src, node_dict):
        return [
            v
            for c in self.bdg.get_slice_data(src, node_dict)    # 返回的是切片结果列表[id,id,...]，src下的所有节点（包括src）
            for v in self.bdg.cluster_list[c]                   # ？？？
        ][::-1]     # [::-1] 意思是反转列表

    def get_fslice_data(self, src, node_dict):
        return [
            v
            for c in self.fdg.get_slice_data(src, node_dict)
            for v in self.fdg.cluster_list[c]
        ]

    def __init__(self, proj, fid, ast, cdg, ddg, node_dict):
        self.fid = fid
        self.proj = proj
        self.ast_edge_dict = ast
        self.cdg_edge_dict = cdg
        self.ddg_edge_dict = ddg
        self.fdg = self.bdg = None
        self.ast = AST(
            self.proj,
            self.fid,
            [self.ast_edge_dict],
            node_dict,
        )
        self.ret = self.ast.edge_dict[fid][-1]

        self.bdg = XDG(
            self.proj,
            self.fid,
            self.ret,
            [self.cdg_edge_dict, self.ddg_edge_dict],
            node_dict,
            reverse=True,
        )
        self.fdg = XDG(
            self.proj,
            self.fid,
            self.fid,
            [self.cdg_edge_dict, self.ddg_edge_dict]
            if FDG_CTRL
            else [self.ddg_edge_dict],
            node_dict,
        )

        self.get_slice_src(node_dict)
        self.src_list = [[v] for v in self.src_dict["ALL"]]             # 每个关注点都以列表的形式存放，即一个关注点放在一个单独的列表
        self.bdg.compute_all_slice_data(self.src_list, node_dict)
        self.fdg.compute_all_slice_data(self.src_list, node_dict)

        if PREPARE_DEBUG:
            tmp_src_dict = {}
            for k in self.src_dict:
                tmp_src_dict[k] = [
                    (src, node_dict[src]["code"]) for src in self.src_dict[k]
                ]
            dump_to_json(tmp_src_dict, f"{db_path}/{proj}/src_dict_{fid}.json")
            dump_to_json(
                list(self.fdg.slice_data.items()),
                f"{db_path}/{proj}/fdg_{fid}_slice_data.json",
            )
            dump_to_json(
                list(self.bdg.slice_data.items()),
                f"{db_path}/{proj}/bdg_{fid}_slice_data.json",
            )
