import heapq, bisect, re
from typing import Dict
from config import db_path, sr_path
from config import PREPARE_DEBUG, SLICE_ALL
from config import FDG_CTRL, BSLICE_TOPO, FSLICE_TOPO
from igraph import *

from data_module.db_access import dump_to_json, dump_to_pickle
from .graph_patch import ast_patcher
from syvc_module import syvc_matcher


def get_edge_set(edge_dict_list, *, reverse=False):
    edge_set = set()
    for edge_dict in edge_dict_list:
        for source, t_list in edge_dict.items():
            [
                edge_set.add((target, source) if reverse else (source, target))
                for target in t_list
                if source != target
            ]
    return edge_set


class AST:
    def get_sub_ast(self, node, node_dict, blk_flag=False, *, fa=None):
        if not blk_flag and (
            node_dict[node]["_label"] == "BLOCK"
            or (
                fa is not None
                and node_dict[fa]["_label"] == "CONTROL_STRUCTURE"
                and node_dict[node]["order"] == len(self.edge_dict[fa])
            )
        ):
            return []

        sub_ast = [node]
        for ch in self.edge_dict.get(node, []):
            sub_ast.extend(self.get_sub_ast(ch, node_dict, blk_flag, fa=node))
        return sub_ast

    def get_slice_src(
        self,
        node: str,
        node_dict: Dict[str, Dict[str, str]],
        src_dict: Dict[str, set[str]],
        sinkcode_dict: Dict[str, list[list]],
        pdg_node,
        def_flag,
        ae_flag,
    ):
        def solve_dict(
            src_dict: Dict[str, set[str]],
            sinkcode_dict: Dict[str, list[list]],
            pdg_node: str,
            keyVar: list | str,
            type_: str
        ):
            """内部函数：去重（保留最后一个）与增加节点"""
            for index, sub in enumerate(sinkcode_dict[type_]):
                if keyVar == sub[-1]:                # 若关键变量出现过，移除它
                    sinkcode_dict[type_].pop(index)
                    src_dict[type_].remove(sub[0])   # 移除旧的节点
                    break
            sinkcode_dict[type_].append([pdg_node, obj['id'],obj['lineNumber'], obj['code'], keyVar])
            src_dict[type_].add(pdg_node)            # 增加这次的节点

        if node_dict[node]["inpdg"]:
            pdg_node = node

        asgn_flag = (
            pdg_node == node
            and node_dict[node]["_label"] == "CALL"
            and "<operator>.assignment" in node_dict[node]["methodFullName"]
        )

        ae_flag &= not asgn_flag

        obj = node_dict[node]
        res = self.edge_dict.get(node, [])      # 直接相连的子节点

        if syvc_matcher.fc_matcher(node, node_dict):
            # 风险函数类型：关键变量是函数参数，即直接子节点
            keyVar = [node_dict[i]['code'] for i in res]   # 获取所有子节点代码
            solve_dict(src_dict, sinkcode_dict, pdg_node, keyVar, 'FC')

        if syvc_matcher.array_matcher(node, node_dict, def_flag):
            # 数组越界类型：关键变量是数组名和索引，即直接子节点
            keyVar = [node_dict[i]['code'] for i in res]
            solve_dict(src_dict, sinkcode_dict, pdg_node, keyVar, 'AU')
            
        if syvc_matcher.pointer_matcher(node, node_dict, def_flag):
            # 指针越界类型：关键变量为指针变量，一种是函数内部的则直接为其code，另一种是函数参数则需要对code进行处理
            if '*' not in obj['code']:
                keyVar = [obj['code']]
            else:
                keyVar = [obj['code'].split('*')[-1].strip(' ')]
            solve_dict(src_dict, sinkcode_dict, pdg_node, keyVar, 'PU')

        if syvc_matcher.integerOverflow(node, node_dict, ae_flag, self):
            # 整数溢出：关键变量为最左侧的操作数
            chr_list = ['+', '*', '/', '<<']    # 减法的单独进行分割，与->进行区分
            keyVar = obj['code']
            for ch in chr_list:
                keyVar = keyVar.split(ch)[0]
            # 用正则表达式将其按照 - 分割，而 -> 连接的不进行分割。如 c->d-e-f 划分为 ['c->d', 'e', 'f']
            keyVar = [re.split(r'-(?!>)', keyVar)[0].strip(' ').strip('(')]
            solve_dict(src_dict, sinkcode_dict, pdg_node, keyVar, 'AE')
        
        if syvc_matcher.NPD_matcher(node, node_dict, def_flag):
            # 空指针解引用：关键变量为去除最后一个 -> 后的变量
            keyVar = '->'.join(re.split('->', obj['code'])[:-1]) # 去除最后一个 -> ，如 a->b->c 为 a->b
            if '[' in keyVar:       # 学姐的需要，将cur[0]->encoding中的cur[0]和cur都视为关键变量
                keyVar = [keyVar, keyVar.split('[')[0]]
            else:
                keyVar = [keyVar]
            solve_dict(src_dict, sinkcode_dict, pdg_node, keyVar, 'NPD')

        if syvc_matcher.pathTraversal_matcher(node, node_dict, def_flag):
            # 路径穿越：关键变量为函数参数
            keyVar = [node_dict[i]['code'] for i in res]
            solve_dict(src_dict, sinkcode_dict, pdg_node, keyVar, 'PT')

        if syvc_matcher.divideByZero_matcher(node, node_dict, def_flag):
            # 除以0：关键变量若是DIV宏则是函数参数，若是/和%则是分母
            if 'DIV' in obj['code']:
                keyVar = [node_dict[i]['code'] for i in res]
            else:
                keyVar = [obj['code'].split('/')[-1].split('%')[-1].strip(' ')]
            solve_dict(src_dict, sinkcode_dict, pdg_node, keyVar, 'DZ')
            
        if syvc_matcher.assert_matcher(node, node_dict, def_flag):
            # 断言：关键变量为函数参数
            keyVar = [node_dict[i]['code'] for i in res]
            solve_dict(src_dict, sinkcode_dict, pdg_node, keyVar, 'AS')

        if syvc_matcher.free_matcher(node, node_dict):
            # 释放：关键变量为函数参数
            keyVar = [node_dict[i]['code'] for i in res]
            solve_dict(src_dict, sinkcode_dict, pdg_node, keyVar, 'FR')
        
        if SLICE_ALL:       # 若配置为SLICE_ALL，则增加所有；否则在GraphDB的init中将上面的所有合并到ALL中
            src_dict["ALL"].add(pdg_node)
            sinkcode_dict["ALL"].append([pdg_node, obj['id'],obj['lineNumber'], obj['code'], ''])

#        all_del_flag = True     # 用于判断非子节点是否需要删除
        for ch in self.edge_dict.get(node, []):
            def_flag = node_dict[ch]["order"] == 1 if asgn_flag else def_flag
            self.get_slice_src(ch, node_dict, src_dict, sinkcode_dict, pdg_node, def_flag, ae_flag)





# 筛选pdg图中所有与sink相关的节点id，需要先把所有节点加入src_dict["new_tp"]列表（还有点问题）
#            del_flag = self.get_slice_src(ch, node_dict, src_dict, pdg_node, def_flag, ae_flag)
#            if del_flag == False: all_del_flag = False
        # 走到叶子节点，根据代码判断是否为sink点，如果不是,删除该节点，返回删除信号;如果是，返回保留信号
        # 走到非叶子节点，根据代码判断是否为sink点，根据子节点返回值判断是否与sink点相关，均为否，则删除该节点，返回删除信号；反之，返回保留信号
#        if all_del_flag and syvc_matcher.new_tp_matcher() == False:
#            src_dict["new_tp"].remove(pdg_node)
#            return True
#        else:
#            return False

            

    def __init__(self, proj, fid, edge_dict_list, node_dict):
        self.fid = fid
        self.proj = proj
        self.edge_dict = {}
        [
            self.edge_dict.setdefault(a, []).append(b)
            for a, b in get_edge_set(edge_dict_list)
        ]
        [
            self.edge_dict[v].sort(key=lambda x: node_dict[x]["order"])
            for v in self.edge_dict
        ]

        ast_patcher.patch_main(self, node_dict)
        self.fa_dict = {v: f for f in self.edge_dict for v in self.edge_dict[f]}
        self.fa_dict[fid] = None

        if PREPARE_DEBUG:
            dump_to_json(self.edge_dict, f"{db_path}/{proj}/ast_{fid}.json")


class XDG:
    def slice(self, src, node_dict):
        pq = [(self.topo_rank[v], v) for v in src]
        heapq.heapify(pq)

        visited_node_set = set(src)
        no_dfs_node_set = set()
        slice_list = []

        last_v = pq[0][1]

        while pq:
            node = heapq.heappop(pq)[1]
            to_list = self.edge_dict.get(node, [])
            slice_list.append(node)
            if node not in no_dfs_node_set:
                if (node,) in self.slice_data:
                    v_list = self.slice_data[(node,)]
                    v_list = v_list[
                        bisect.bisect(
                            v_list,
                            last_v,
                            key=lambda x: self.topo_rank[x],
                        ) :
                    ]
                    for v in v_list:
                        if v not in visited_node_set:
                            heapq.heappush(pq, (self.topo_rank[v], v))
                            visited_node_set.add(v)
                        no_dfs_node_set.add(v)

                    to_list = to_list[
                        : bisect.bisect(
                            to_list,
                            last_v,
                            key=lambda x: self.topo_rank[x],
                        )
                    ]

                    if v_list:
                        last_v = v_list.pop()

                for v in to_list:
                    if v not in visited_node_set:
                        heapq.heappush(pq, (self.topo_rank[v], v))
                        visited_node_set.add(v)

        if not (FSLICE_TOPO, BSLICE_TOPO)[self.reverse]:
            slice_list.sort(
                key=lambda x: (
                    node_dict[self.cluster_list[x][0]]["lineNumber"],
                    node_dict[self.cluster_list[x][0]]["columnNumber"],
                ),
                reverse=self.reverse,
            )

        return slice_list

    def get_std_src(self, raw_src):
        return tuple(
            sorted(
                {self.cluster_dict[v] for v in raw_src if v in self.cluster_dict},
                key=lambda x: self.topo_rank[x],
            )
        )

    def compute_all_slice_data(self, src_list, node_dict):
        std_src_list = []
        for raw_src in src_list:
            std_src = self.get_std_src(raw_src)
            if std_src:
                std_src_list.append(std_src)

        for std_src in sorted(
            std_src_list,
            key=lambda x: self.topo_rank[x[0]],
            reverse=True,
        ):
            if std_src not in self.slice_data:
                self.slice_data[std_src] = self.slice(std_src, node_dict)

    def get_slice_data(self, raw_src, node_dict):
        std_src = self.get_std_src(raw_src)
        if not std_src:
            return []
        else:
            if std_src not in self.slice_data:
                self.slice_data[std_src] = self.slice(std_src, node_dict)
            return self.slice_data[std_src]

    def topo_sort(self, node_dict):
        self.topo_list = []
        self.topo_rank = [None] * len(self.dag.vs)
        in_degree_list = self.dag.indegree()
        """在数据依赖边修复后，将下面修改为：
        stack = [self.cluster_dict[self.src]]
        """
        stack = [i for i, d in enumerate(in_degree_list) if not d]
        while stack:
            node = stack.pop()
            self.topo_list.append(node)
            target_list = sorted(
                self.dag.successors(node),
                key=lambda x: (
                    node_dict[self.cluster_list[x][0]]["lineNumber"],
                    node_dict[self.cluster_list[x][0]]["columnNumber"],
                ),
                reverse=not self.reverse,
            )

            # print(node, [self.cluster_list[v] for v in target_list])

            for target in target_list:
                in_degree_list[target] -= 1
                if not in_degree_list[target]:
                    stack.append(target)

        # assert not any(in_degree_list)

        for rank, node in enumerate(self.topo_list):
            self.topo_rank[node] = rank

    def __init__(
        self,
        proj,
        fid,
        src,
        edge_dict_list,
        node_dict,
        *,
        reverse=False,
    ) -> None:
        self.src = src
        self.fid = fid
        self.proj = proj
        self.reverse = reverse
        self.xdg = Graph.TupleList(
            get_edge_set(edge_dict_list, reverse=reverse), directed=True
        )
        c = self.xdg.clusters()
        self.cluster_list = [
            sorted(
                [self.xdg.vs[v]["name"] for v in node_list],
                key=lambda x: (
                    node_dict[x]["lineNumber"],
                    node_dict[x]["columnNumber"],
                ),
                reverse=self.reverse,
            )
            for node_list in c
        ]
        self.cluster_dict = {
            v: i for i, cluster in enumerate(self.cluster_list) for v in cluster
        }
        self.dag = c.cluster_graph()

        self.topo_sort(node_dict)

        self.edge_dict = {}
        [self.edge_dict.setdefault(e.source, []).append(e.target) for e in self.dag.es]
        [
            self.edge_dict[v].sort(key=lambda x: self.topo_rank[x])
            for v in self.edge_dict
        ]

        self.slice_data = {}

        if PREPARE_DEBUG:
            prefix_path = f"{db_path}/{proj}/{'fb'[reverse]}dg_{fid}"
            self.xdg.write_dot(f"{prefix_path}.dot")
            self.dag.write_dot(f"{prefix_path}_dag.dot")
            dump_to_json(self.cluster_dict, f"{prefix_path}_cluster_dict.json")
            dump_to_json(self.cluster_list, f"{prefix_path}_cluster_list.json")
            dump_to_json(self.topo_list, f"{prefix_path}_topo_list.json")
            dump_to_json(self.topo_rank, f"{prefix_path}_topo_rank.json")
            dump_to_json(self.edge_dict, f"{prefix_path}_edge_dict.json")

###########################################################################################
# 在这里对新增的sink类型进行初始化
class GraphDB:
    def get_slice_src(self, node_dict):
        self.type_list = ["ALL", "AU", "PU", "AE", "FC", "NPD", "PT", "DZ", "AS", "FR"]
        self.src_dict = {type: set() for type in self.type_list}
        self.sinkcode_dict = {type: list() for type in self.type_list}
        self.ast.get_slice_src(self.fid, node_dict, self.src_dict, self.sinkcode_dict, None, False, False)


    def get_bslice_data(self, src, node_dict):
        return [
            v
            for c in self.bdg.get_slice_data(src, node_dict)
            for v in self.bdg.cluster_list[c]
        ][::-1]

    def get_fslice_data(self, src, node_dict):
        return [
            v
            for c in self.fdg.get_slice_data(src, node_dict)
            for v in self.fdg.cluster_list[c]
        ]

    def __init__(self, proj, fid, ast, cdg, ddg, node_dict):
        self.fid = fid
        self.proj = proj
        self.ast_edge_dict = ast
        self.cdg_edge_dict = cdg
        self.ddg_edge_dict = ddg
        self.fdg = self.bdg = None
        self.ast = AST(
            self.proj,
            self.fid,
            [self.ast_edge_dict],
            node_dict,
        )
        self.ret = self.ast.edge_dict[fid][-1]

        self.bdg = XDG(
            self.proj,
            self.fid,
            self.ret,
            [self.cdg_edge_dict, self.ddg_edge_dict],
            node_dict,
            reverse=True,
        )
        self.fdg = XDG(
            self.proj,
            self.fid,
            self.fid,
            [self.cdg_edge_dict, self.ddg_edge_dict]
            if FDG_CTRL
            else [self.ddg_edge_dict],
            node_dict,
        )

        self.get_slice_src(node_dict)
        if not SLICE_ALL:       # 将所有类型的合并到ALL中，用于切片和查看
            self.src_dict['ALL'] = set([v for vs in self.src_dict.values() for v in vs])
            self.sinkcode_dict['ALL'] = [v for vs in self.sinkcode_dict.values() for v in vs]
        self.src_list = [[v] for v in self.src_dict["ALL"]]
        self.bdg.compute_all_slice_data(self.src_list, node_dict)
        self.fdg.compute_all_slice_data(self.src_list, node_dict)
        [dump_to_json(self.sinkcode_dict[type], f"{sr_path}/{proj}/sinkcode_{type}.json") for type in self.type_list]
        dump_to_pickle(self.sinkcode_dict,f"{sr_path}/{proj}/sink_cv_tmp.db")
        if PREPARE_DEBUG:
            tmp_src_dict = {}
            for k in self.src_dict:
                tmp_src_dict[k] = [
                    (src, node_dict[src]["code"]) for src in self.src_dict[k]
                ]
            dump_to_json(tmp_src_dict, f"{db_path}/{proj}/src_dict_{fid}.json")
            dump_to_json(
                list(self.fdg.slice_data.items()),
                f"{db_path}/{proj}/fdg_{fid}_slice_data.json",
            )
            dump_to_json(
                list(self.bdg.slice_data.items()),
                f"{db_path}/{proj}/bdg_{fid}_slice_data.json",
            )
