from copy import copy
from re import A
from config import fslice_depth, bslice_depth
from config import BSLICE_CALL


def get_fixed_list(fid, node_list, node_dict, graph_dict):

    # print([(node, node_dict[node]["code"]) for node in node_list])

    tmp_node_list = []
    all_node_set = set()
    for node in reversed(node_list):
        if node not in all_node_set:
            all_node_set.add(node)
            tmp_node_list.append(node)

    node_list = []
    tmp_node_set = set()
    del_node_set = set()
    for node in reversed(tmp_node_list):

        # print(node, graph_dict[fid].ast.get_sub_ast(node, node_dict))

        for v in graph_dict[fid].ast.get_sub_ast(node, node_dict):
            if node_dict[v]["_label"] == "IDENTIFIER":
                r = node_dict[v]["refto"]
                if r != "LOST" and r not in all_node_set:
                    node_list.append(r)
                    all_node_set.add(r)

                    del_node_set.add(r) if r in tmp_node_set else tmp_node_set.add(r)

            del_node_set.add(v) if v in tmp_node_set else tmp_node_set.add(v)

        fa = graph_dict[fid].ast.fa_dict[node]
        fa_is_ctrl_statement = (
            fa is not None
            and node_dict[fa]["_label"] == "CONTROL_STRUCTURE"
            and node_dict[fa]["controlStructureType"]
            in ("IF", "FOR", "WHILE", "SWITCH")
        )

        if fa_is_ctrl_statement and fa not in all_node_set:
            node_list.append(fa)
            all_node_set.add(fa)

            # print("for", fa, graph_dict[fid].ast.get_sub_ast(fa, node_dict))

            [
                del_node_set.add(v) if v in tmp_node_set else tmp_node_set.add(v)
                for v in graph_dict[fid].ast.get_sub_ast(fa, node_dict)
            ]

        node_list.append(node)

    return [
        (p, p not in del_node_set and node_dict[p]["_label"] != "METHOD_RETURN")        # 返回的是二元组的列表
        for p in node_list
        if p not in del_node_set
        or node_dict[p]["_label"] == "CALL"
        and node_dict[p]["callto"] != "EXTN"
    ]


def get_fslice_result(
    fid,
    src,
    node_dict,
    graph_dict,
    fslice_depth,
    visited_callee,
):
    slice_result = []
    if not fslice_depth:
        return slice_result

    current_result = get_fixed_list(
        fid,
        graph_dict[fid].get_fslice_data(src, node_dict),
        node_dict,
        graph_dict,
    )

    for t in current_result:
        v = t[0]
        if (
            node_dict[v]["_label"] == "CALL"
            and node_dict[v]["callto"] != "EXTN"
            and v not in visited_callee
        ):
            cfid = node_dict[v]["callto"]
            """可以实现基于函数调用参数的出发点的筛选"""
            visited_callee.add(v)
            slice_result.extend(
                get_fslice_result(
                    cfid,
                    [cfid],
                    node_dict,
                    graph_dict,
                    fslice_depth - 1,
                    visited_callee,
                )
            )
        slice_result.append(t)

    return slice_result


def get_bfslice_result(                 # 获取前后向切片的节点序列，back，front
    fid,
    src,
    node_dict,
    graph_dict,
    callin_dict,
    bslice_depth,           # 在config.py中设置了初值
    fslice_depth,           # 同上
    slice_result,
    current_result,         # 初始为空的列表
    visited_callee,         # 初始为空的无序不重复元素集
):
    if not bslice_depth:            # 后向切片深度已经减至0
        slice_result.append(current_result)
        return

    current_visited_callee = copy(visited_callee)

    slice_data = get_fixed_list(                        # 对前向与后向切片获取的节点进行修正
        fid,
        graph_dict[fid].get_bslice_data(src, node_dict)         # get_bslice_data：获取起点的函数内后向切片结果
        + graph_dict[fid].get_fslice_data(src, node_dict),      # get_fslice_data：获取起点的函数内前向切片结果
        node_dict,                                              # 前向不考虑控制边，后向不考虑函数调用
        graph_dict,
    )

    flag = BSLICE_CALL
    tmp = current_result
    current_result = []

    for v, p in slice_data:             # v是节点id，p是一个bool类型的变量
        if v == src[0]:
            """这里假定 src 只有一个节点，如果有多个则需要修改"""
            current_result.extend(tmp)          # 找到了关注点，接下来是前向切片的节点了，
            flag = True                         # 前向切片，需要考虑函数调用
        elif (
            flag
            and node_dict[v]["_label"] == "CALL"
            and node_dict[v]["callto"] != "EXTN"
            and v not in visited_callee     # 不重复
        ):
            cfid = node_dict[v]["callto"]
            """可以实现基于函数调用参数的出发点的筛选"""
            visited_callee.add(v)
            current_result.extend(
                get_fslice_result(
                    cfid,
                    [cfid],
                    node_dict,
                    graph_dict,
                    fslice_depth - 1,
                    visited_callee,
                )
            )
        current_result.append((v, p))           # 对于后向切片得到的节点，直接加入current_result中；对于前向的，除了自身节点外，
                                                # 还需要判断是否为内部函数调用，如果是，则以函数头为关注点，进行前向切片。

    flag = False

    for cfid, cid_list in callin_dict[fid].items():     # 以每一个调用了内部函数的节点为关注点（不与之前找过的重复），
        for cid in cid_list:                            # 进行前后向切片
            if cid not in visited_callee:   # 不重复
                visited_callee.add(cid)
                get_bfslice_result(
                    cfid,
                    [cid],
                    node_dict,
                    graph_dict,
                    callin_dict,
                    bslice_depth - 1,
                    fslice_depth - 1,
                    slice_result,
                    current_result,
                    visited_callee,
                )
                visited_callee = copy(current_visited_callee)
                flag = True
    if not flag:            # 确保不重复加入节点，如果有一个cid不在visited_callee中，则在之后的调用中会加入之前尚未添加的节点
        slice_result.append(current_result)


def get_slice_result(
    fid,
    src,
    node_dict,
    graph_dict,
    callin_dict,
    bslice_depth,
    fslice_depth,
):
    slice_result = []
    get_bfslice_result(         # 获取后向、前向切片结果（back、front）
        fid,    # 函数id
        src,    # 函数内的某个关注点
        node_dict,  # 节点信息表
        graph_dict,
        callin_dict,
        bslice_depth,   # 后向切片深度（提前设置好的）
        fslice_depth,   # 前向切片深度（提前设置好的）
        slice_result,   # 最终结果列表
        list(),         # 空列表（后续使用）
        set(),          # 创建一个无序不重复元素集（后续使用）
    )
    # print(fid, src, [node_dict[v]["code"] for v in src], slice_result)
    return slice_result


def get_all_slice_result(
    fid,
    node_dict,
    graph_dict,
    callin_dict,
):
    return {
        src[0]: get_slice_result(       # 这里的src也是一个列表，但列表中仅有一个元素
            fid,
            src,                        
            node_dict,
            graph_dict,
            callin_dict,
            bslice_depth,
            fslice_depth,
        )
        for src in graph_dict[fid].src_list
    }
