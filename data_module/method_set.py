ae_func_1 = {
    "<operator>.multiplication",
    "<operator>.division",
    "<operator>.shiftLeft",
    "<operator>.assignmentMultiplication",
    "<operator>.assignmentDivision",
    "<operators>.assignmentShiftLeft",  # 后期名称可能改正
}

ae_func_2 = {
    "<operator>.subtraction",
    "<operator>.addition",
    "<operator>.assignmentMinus",
    "<operator>.assignmentPlus",
}

# unsigned 在类型的前还是后，这通过具体例子确定，挺奇怪的
int_types = {
    "char", "unsigned char","char unsigned"
    "short", "unsigned short", "short unsigned",
    "int", "unsigned int", "int unsigned",
    "long", "unsigned long", "long unsigned",
    "long long", "unsigned long long", "long long unsigned",
    "<empty>"
}

# 布尔和比较运算用于 assert 的参数
boolean_operations = {
    '<operator>.logicalAnd',
    '<operator>.logicalOr',
    '<operator>.logicalNot'
}
comparison_operations = {
    '<operator>.greaterThan',
    '<operator>.greaterEqualsThan',
    '<operator>.lessThan',
    '<operator>.lessEqualsThan',
    '<operator>.equals',
    '<operator>.notEquals',
}

# 用作缓冲区溢出的安全检查
compare_operator = {
    "<operator>.greaterThan",
    "<operator>.greaterEqualsThan",
    "<operator>.lessThan",
    "<operator>.lessEqualsThan"
}

arithmetic_operator = {
    "<operator>.subtraction",
    "<operator>.addition",
    "<operator>.multiplication",
    "<operator>.division",
    "<operator>.modulo"
}

def isConstant(node_dict, node) -> bool:
    """判断一个节点是否为常量"""
    return (
        node_dict[node]['_label'] == 'LITERAL'
        or (node_dict[node]['_label'] == 'CALL' and node_dict[node]['methodFullName'] == '<operator>.sizeOf')
    )