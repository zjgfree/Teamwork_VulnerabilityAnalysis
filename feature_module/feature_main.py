import time
import collections
from multiprocessing import Pool
from alive_progress import alive_bar
from config import FEATURE_DEBUG
from config import db_path, sr_path
from data_module.db_access import *
from .source_match import match_source


def extract_cv(proj):
    # {fid: {tp: [...]}}
    sink_cv_dict = load_from_pickle(f"{sr_path}/{proj}/sink_code.db")
    newsink_dict = {}
    for fid, v1 in sink_cv_dict.items():
        newsink_dict[fid] = {}
        for tp, vs in v1.items():
            for v in vs:
                key = v[0] + "_" + tp
                newsink_dict[fid][key] = {
                    "type": tp,
                    "code": v[3],
                    "key_value": v[4]
                }
    dump_to_pickle(newsink_dict, f"{sr_path}/{proj}/sink_cv_dict.db")
    return newsink_dict

def is_vulnerable(source_dict:dict, security_check:dict):
    # 一个切片中有good_source/security_check就是无漏洞的
    if source_dict['good_source'] != {} or security_check != {}:
        return "Non_vulnerable"
    # 上述为空且有unknow_source是有隐式漏洞的
    else:
        if source_dict['unknow_source'] != {}:
            return "Latent_vulnerability"
    return "-1"

def extract_feature(proj, fid_set):
    node_dict = load_from_pickle(f"{db_path}/{proj}/node_dict.db")
    graph_dict = load_from_pickle(f"{db_path}/{proj}/graph_dict.db")
    # slice_dict 格式：{id_func:{id_sink: [(id_slice, bool), ]}
    slice_dict = load_from_pickle(f"{sr_path}/{proj}/all_slice_result_dict.db" )
    sink_dict = extract_cv(proj)

    # 需要将每个切片拆分出来，获取到对应切片的类型
    # feature_result = collections.defaultdict(int,feature_result)
    feature_result = {}
    source_num = 0  # source个数
    for fid in fid_set:
        feature_result[fid] = {}
        feature_result[fid] = collections.defaultdict(int,feature_result[fid])
        for tp in ("FR","NPD","PT","DZ","AS","FC", "AU", "PU", "AE"):
            for src in graph_dict[fid].src_dict[tp]:
                # 在切片db中获取到对应src的切片
                # slice_result 中是 id_slice 列表
                slice_result = [item[0] for item in slice_dict[fid][src][0]]
                key = src+"_"+tp
                # 匹配
                match_source_res = match_source(fid, node_dict, graph_dict, slice_result, sink_dict[fid][key]["key_value"], tp)
                feature_result[fid][key] = {
                    "type": tp,
                    "slice": slice_result,
                    "key_value": sink_dict[fid][key]["key_value"],
                    "sink_code": sink_dict[fid][key]["code"],
                    "source": match_source_res[0],
                    "security_check": match_source_res[1],
                    "label": is_vulnerable(match_source_res[0], match_source_res[1])
                }
                tmp_l = feature_result[fid][key]["source"]
                if tmp_l["good_source"] or tmp_l["unknow_source"]["custom_function"] or tmp_l["unknow_source"]["function_parameter"] or tmp_l["unknow_source"]["global_variable"]:
                    source_num += 1
#    with open("log.txt","a") as l:      # 记录每个项目的source个数
#        l.write(f"\tproject {proj} has !:{source_num}:! source\n")
    if source_num == 0:                 # 仅记录没有source的项目
        with open("log.txt","a") as l:      
            l.write(f"\tproject {proj} has !:{source_num}:! source\n")

    dump_to_json(feature_result,f"{sr_path}/{proj}/feature_dict.json")


def feature():
    start = time.perf_counter()
    print("Extract slice feature... ")
    proj_dict = load_from_pickle(f"{db_path}/proj_dict.db")
    with open("log.txt","a") as l:
        l.write("开始获取feature\n")
    with alive_bar(len(proj_dict)) as bar:
        bar.title = f"{'Extract slice feature':^30}"
        if FEATURE_DEBUG:
            for proj, fid_set in proj_dict.items():
                extract_feature(proj, fid_set)
                bar()
        else:
            with Pool() as p:
                for proj, fid_set in proj_dict.items():
                    p.apply_async(
                        extract_feature,
                        (proj, fid_set),
                        callback=lambda x: bar(),
                    )
                p.close()
                p.join()
    with open("log.txt","a") as l:
        l.write("获取结束\n\n")
    print(f"Done, used {time.perf_counter() - start:<.2f}s\n")

    # # 先不做多进程处理
    # for proj,fid_set in proj_dict.items():
    #     extract_feature(proj, fid_set)