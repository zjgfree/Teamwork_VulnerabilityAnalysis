import time
import collections
from multiprocessing import Pool
from alive_progress import alive_bar
from config import FEATURE_DEBUG
from config import db_path, sr_path
from data_module.db_access import *
from .source_match import match_source


def extract_cv(proj):
    sink_cv_dict = load_from_pickle(f"{sr_path}/{proj}/sink_cv_tmp.db")
    # print("sink_cv: ", sink_cv_dict)
    newsink_dict = {}
    for tp, value_list in sink_cv_dict.items():
        if tp == 'ALL' or value_list == []:
            continue
        else:
            for value in value_list:
                sink_id = value[0]
                # print("sink_id: ", sink_id)
                # 同一个sink_id可能对应两种类型的sink，将key改成sink_id+tp
                key = sink_id+"_"+tp
                newsink_dict[key] = {}
                newsink_dict[key] = collections.defaultdict(str, newsink_dict[key])
                newsink_dict[key]["type"] = tp
                newsink_dict[key]["code"] = value[3]
                newsink_dict[key]["key_value"] = value[4]
    dump_to_pickle(newsink_dict, f"{sr_path}/{proj}/sink_cv_dict.db")
    # print("sink_cv: ", newsink_dict)
    # print("sink: ", [key 
    #                for key in newsink_dict.keys()])
    return newsink_dict

def is_vulnerable(source_dict:dict
                  ,security_check:dict):
    # 一个切片中有good_source/security_check就是无漏洞的
    if source_dict['good_source'] != {} or security_check != {}:
        return "Non_vulnerable"
    # 上述为空且有unknow_source是有隐式漏洞的
    else:
        if source_dict['unknow_source'] != {}:
            return "Latent_vulnerability"
    return "-1"




def extract_feature(proj, fid_set):
    node_dict = load_from_pickle(f"{db_path}/{proj}/node_dict.db")
    graph_dict = load_from_pickle(f"{db_path}/{proj}/graph_dict.db")
    # slice_dict 格式：{id_func:{id_sink: [(id_slice, bool), ]}
    slice_dict = load_from_pickle(f"{sr_path}/{proj}/all_slice_result_dict.db" )
    sink_dict = extract_cv(proj)

    


    # 需要将每个切片拆分出来，获取到对应切片的类型
    # feature_result = collections.defaultdict(int,feature_result)
    feature_result = {}
    source_num = 0  # source个数
    for fid in fid_set:
        feature_result[fid] = {}
        feature_result[fid] = collections.defaultdict(int,feature_result[fid])
        for tp in ("FR","NPD","PT","DZ","AS","FC", "AU", "PU", "AE"):
            for src in graph_dict[fid].src_dict[tp]:  
                # 在切片db中获取到对应src的切片
                # slice_result 中是 id_slice 列表
                slice_result = [item[0] for item in slice_dict[fid][src][0]]
                # print("src: ", src)
                # print("slice_result: ",slice_result)
                key = src+"_"+tp
                # 匹配
                feature_result[fid][key] = {}
                feature_result[fid][key] = collections.defaultdict(str,feature_result[fid][key])
                feature_result[fid][key]["type"] = tp               
                feature_result[fid][key]["slice"] = slice_result
                # if int(src) not in list(sink_dict.keys()):
                #     feature_result[fid][src]["key_value"] = "-1"
                #     continue
                feature_result[fid][key]["key_value"] = sink_dict[key]["key_value"]
                feature_result[fid][key]["sink_code"] = sink_dict[key]["code"]
                feature_result[fid][key]["source"], feature_result[fid][key]["security_check"]= match_source(fid, node_dict, graph_dict, slice_result,sink_dict[key]["key_value"], tp)
                tmp_l = feature_result[fid][key]["source"]
                if tmp_l["good_source"] or tmp_l["unknow_source"]["custom_function"] or tmp_l["unknow_source"]["function_parameter"] or tmp_l["unknow_source"]["global_variable"]:
                    source_num += 1
                feature_result[fid][key]["label"] = is_vulnerable(feature_result[fid][key]["source"],feature_result[fid][key]["security_check"])
#    with open("log.txt","a") as l:      # 记录每个项目的source个数
#        l.write(f"\tproject {proj} has !:{source_num}:! source\n")
    if source_num == 0:                 # 仅记录没有source的项目
        with open("log.txt","a") as l:      
            l.write(f"\tproject {proj} has !:{source_num}:! source\n")

    dump_to_json(feature_result,f"{sr_path}/{proj}/feature_dict.json")


def feature():
    start = time.perf_counter()
    print("Extract slice feature... ")
    proj_dict = load_from_pickle(f"{db_path}/proj_dict.db")
    with open("log.txt","a") as l:
        l.write("开始获取feature\n")
    with alive_bar(len(proj_dict)) as bar:
        bar.title = f"{'Extract slice feature':^30}"
        if FEATURE_DEBUG:
            for proj, fid_set in proj_dict.items():
                extract_feature(proj, fid_set)
                bar()
        else:
            with Pool() as p:
                for proj, fid_set in proj_dict.items():
                    p.apply_async(
                        extract_feature,
                        (proj, fid_set),
                        callback=lambda x: bar(),
                    )
                p.close()
                p.join()
    with open("log.txt","a") as l:
        l.write("获取结束\n\n")
    print(f"Done, used {time.perf_counter() - start:<.2f}s\n")

    # # 先不做多进程处理
    # for proj,fid_set in proj_dict.items():
    #     extract_feature(proj, fid_set)