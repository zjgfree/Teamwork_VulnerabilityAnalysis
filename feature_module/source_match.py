from data_module.db_access import load_from_pickle
from graph_module import graph_class
from data_module.method_set import *

cfuns = load_from_pickle("feature_module/cfuns.db")

def security_check_OF(node, node_dict, ast, sub_ast, cv):
    """Buffer Overflow"""
    flag_compare = False
    flag_cv = False
    # cv需要出现在 if 语句中的比较语句中，比如&&和||连接的
    compare_statements = [] # 比较语句列表
    if node_dict[node]['_label'] == "CONTROL_STRUCTURE" and node_dict[node]['controlStructureType'] == "IF":
        for sub_node in sub_ast:
            # 将 sub_ast 分为以 && 和 || 连接的多个节点：都是比较语句
            if node_dict[sub_node]['_label'] == 'CALL' and node_dict[sub_node]['methodFullName'] in ('<operator>.logicalAnd', '<operator>.logicalOr'):
                # 若内部还有 && 和 || 连接，则去除自身，并将子节点加入
                if node in compare_statements:
                    compare_statements.remove(node)
                compare_statements += ast.edge_dict.get(node, [])
        if compare_statements == []:    # 没有通过 && 和 || 连接，则为自身
            compare_statements = [node]
        for state in compare_statements:
            # 对每个比较语句进行判断
            subs = ast.get_sub_ast(state, node_dict)
            for sub_node in subs:
                if node_dict[sub_node]['code'] == cv:
                    flag_cv = True
                if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name'] in compare_operator:
                    flag_compare = True
                if flag_cv and flag_compare:
                    return True
    # 通过min函数进行安全检查：index = min(a, len)。类似的 index = a > len ? len: a;
    flag_condition = flag_compare = False
    if node_dict[node]['_label'] == 'CALL' and node_dict[node]['name'] == "<operator>.assignment" and cv in node_dict[node]['code'].split('=')[0]:
        for sub_node in sub_ast:
            if node_dict[sub_node]['_label'] == 'CALL':
                # 若包含 min 函数
                if node_dict[sub_node]['methodFullName'] == 'min':
                    return True
                # 若包含 ?: 运算符且右侧是大小比较运算符
                if node_dict[sub_node]['methodFullName'] == '<operator>.conditional':
                    flag_condition = True
                if node_dict[sub_node]['name'] in compare_operator:
                    flag_compare = True
                if flag_condition and flag_compare:
                    return True
    return False

def security_check_NPD(node, node_dict, ast, sub_ast, cv):
    obj = node_dict[node]
    sub = ast.edge_dict.get(node, [])
    # strm = &strm1 
    if obj['_label'] == '<operator>.assignment' and node_dict[sub[-1]]['_label'] == 'CALL' and node_dict[sub[-1]]['methodFullName'] == '<operator>.addressOf':
        return True
    flag_null = False
    flag_cv = False
    if node_dict[node]['_label'] == "CONTROL_STRUCTURE" and node_dict[node]['controlStructureType'] == "IF":
        for sub_node in sub_ast:
            if node_dict[sub_node]['code'] == cv :
                flag_cv = True
            # if (!first)
            if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name']=="<operator>.logicalNot" :
                code = node_dict[sub_node]['code']
                if code.replace("!","") == cv:
                    return True
            # if (face == NULL)
            if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name']=="<operator>.equals" :
                code = node_dict[sub_node]['code'].split("==")
                if(
                    code[0].strip()==cv and code[1].strip()== "NULL"
                    or code[0].strip()== "NULL" and code[1].strip()== cv
                ):
                    return True
            # if (face)
            if len(sub_ast) == 2 :
                flag_null = True    
    if flag_cv and flag_null:
        return True
    return False

def security_check_DZ(node,node_dict,sub_ast, cv): 

    if node_dict[node]['_label'] == "CONTROL_STRUCTURE" and node_dict[node]['controlStructureType'] == "IF":
        for sub_node in sub_ast:

            # if(!num)
            if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name']=="<operator>.logicalNot" :
                code = node_dict[sub_node]['code']
                if code.replace("!","") == cv:
                    return True
                
            # if(num == 0)
            if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name']=="<operator>.equals" :
                code = node_dict[sub_node]['code'].split("==")
                if(code[0].strip()==cv and code[1].strip()== "0"):
                    return True

            # if(num<1)
            if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name']=="<operator>.lessthan" :
                code = node_dict[sub_node]['code'].split("<")
                if(code[0].strip()==cv and code[1].strip()== "1"):
                    return True
                
    return False

def match_source(
    fid, 
    node_dict, 
    graph_dict, 
    slice_result:list, 
    cv_s, 
    tp
):
    def compose_cv(node):
        return node_dict[node]['code'] + ":" + str(node_dict[node]['lineNumber'])
    slice_result.reverse()
    cv_list = []
    for cv in cv_s:
        if "lineNumber" in node_dict[slice_result[0]]: cv_list.append(cv+":"+str(node_dict[slice_result[0]]['lineNumber']))
        else: cv_list.append(cv+":"+"no lineNumber")
    good_source = {}
    unknow_source = {i: {} for i in ("custom_function", "function_parameter", "global_variable")}
    # 可能多个关键变量都是函数参数，因此需要写成一个列表
    unknow_source['function_parameter'][fid] = []
    security_check = {}
    ast = graph_dict[fid].ast
    for cv_line in cv_list:     # 之后都是放在 cv_list 的末尾的，并不会影响循环
        # 对每个关键变量
        line = cv_line.split(":")[1]
        cv = cv_line.split(":")[0]

        # 若某一个语句中存在值修改语句
        if any(
            # 必须是其前面的语句，免得结构体成员和外部成员名称相同。如 CVE-2014-0143-CWE-190-qemu-8f4754e-bdrv_create()-0.C
            "lineNumber" in node_dict[node] and node_dict[node]['lineNumber'] < int(line)
            and node_dict[node]['_label'] == 'CALL'
            and 
            # 赋值语句类型
            (node_dict[node]['name'] == "<operator>.assignment" 
            and cv == node_dict[ast.edge_dict.get(node, [])[0]]['code']     # 若赋值语句的左节点是 cv 才进行
            or 
            # 自定义函数的引用传递参数
            '<operator>' not in node_dict[node]['methodFullName']
            and node_dict[node]['methodFullName'] not in cfuns
            and any(node_dict[sub_node]['code'] == cv 
                    and "name" in node_dict[sub_node] and node_dict[sub_node]['name'] == '<operator>.addressOf' 
                    for sub_node in ast.edge_dict.get(node, [])))
            for node in slice_result
        ):
            for node in slice_result:
                # 从下到上，对切片结果中的每一个语句节点
                if "lineNumber" in node_dict[node] and node_dict[node]['lineNumber'] >= int(line):   # 若在 cv 下方，不考虑
                    continue

                # 下面所需要的重要变量
                sub_ast = ast.get_sub_ast(node,node_dict)
                sub = ast.edge_dict.get(node, [])   # 直接相连的子节点
                obj = node_dict[node]

                # 判断当前语句是不是安全检查语句（根据类型）
                
                # 对于缓存区溢出和整数溢出，安全检查为比较大小
                if tp in ["AU","PU","FC","AE"]:
                    if(security_check_OF(node,node_dict, ast, sub_ast, cv)):
                        security_check[node] = node_dict[node]['code'] +"  cv: "+cv
                # 对于空指针解引用来说，安全检查为判断是否为空
                elif tp == "NPD":
                    if(security_check_NPD(node,node_dict, ast, sub_ast, cv)):
                        security_check[node] = node_dict[node]['code'] +"  cv: "+cv    
                elif tp == "DZ":
                    if(security_check_DZ(node,node_dict,sub_ast, cv)):
                        security_check[node] = node_dict[node]['code'] +"  cv: "+cv   
                
                # source 点匹配
                # 值修改语句：赋值语句
                if obj['_label'] == 'CALL' and obj['name'] == "<operator>.assignment":
                    if cv == node_dict[sub[0]]['code']:     # 若赋值语句的左节点是 cv 才进行
                        right_obj = node_dict[sub[-1]]
                        right_sub = ast.edge_dict.get(sub[-1], [])
                        # cow_header = (const void *)buf 情况，先去除类型转换，因下面多次使用到 sub[-1]，也应将其换成后者
                        if right_obj['_label'] == 'CALL' and right_obj['methodFullName'] == '<operator>.cast':
                            sub[-1] = right_sub[-1]
                            right_obj = node_dict[sub[-1]]
                            right_sub = ast.edge_dict.get(sub[-1], [])
                        # cv = var, IDENTIFIER
                        if right_obj['_label'] == 'IDENTIFIER':
                            if compose_cv(sub[-1]) not in cv_list:
                                cv_list.append(compose_cv(sub[-1]))
                            break
                        # 若右侧都是常数，为 good_source
                        elif all(isConstant(node_dict[sub_node]) for sub_node in ast.get_sub_ast(sub[-1], node_dict)):
                            good_source[node] = node_dict[node]['code']+"  cv: "+cv
                            break
                        elif right_obj['_label'] == 'CALL':
                            # cv = array[i]，<operator>.indirectIndexAccess
                            # cv = struct_ptr->member, <operator>.indirectFieldAccess
                            if right_obj['methodFullName'] in ('<operator>.indirectIndexAccess' , '<operator>.indirectFieldAccess'):
                                cv_list.extend(compose_cv(i) for i in (sub[-1], right_sub[0]) if compose_cv(i) not in cv_list) # array[i], array
                                break
                            # cv = a + b, arithmetic_operator 
                            elif right_obj['methodFullName'] in arithmetic_operator:
                                cv_list.extend(compose_cv(i) for i in right_sub if compose_cv(i) not in cv_list and not isConstant(node_dict[i]))
                                break
                            elif '<operator>' not in right_obj['methodFullName']:
                                # 自定义函数赋值
                                if right_obj['methodFullName'] not in cfuns:
                                    unknow_source['custom_function'][node] = node_dict[node]['code']+"  cv: "+cv
                                    break
                                # C 库函数赋值
                                else:
                                    # 根据类型判断当前语句中关键变量对应的是否为good_source
                                    if (
                                        (tp in ["AU","PU","FC"]
                                        and any(node_dict[sub_node]['_label'] == "CALL" and "allc" in node_dict[sub_node]['name'] for sub_node in sub_ast))
                                        or
                                        # Free 类型，且 cv 和 NULL 都存在于节点之中
                                        (tp == "FR"
                                        and all(item in (node_dict[sub_node]['code'] for sub_node in sub_ast) for item in (cv, 'NULL') ))
                                    ):
                                        good_source[node] = node_dict[node]['code']+"  cv: "+cv
                                    else:
                                        cv_list.extend(compose_cv(i) for i in right_sub if compose_cv(i) not in cv_list and not isConstant(node_dict[i]))
                                    break
                        else:
                            # 记录一下可能发生的其他情况
                            with open("log.txt","a") as l:
                                l.write(f"In assignment but not considered: \n\tnode: {node}, cv: {cv}, code: {node_dict[node]['code']}")
                            break
                # 值修改语句：自定义函数的引用传递的参数
                elif obj['_label'] == 'CALL' and '<operator>' not in obj['methodFullName'] and obj['methodFullName'] not in cfuns:
                    if any(node_dict[sub_node]['code'] == cv
                           and "name" in node_dict[sub_node]
                           and node_dict[sub_node]['name'] == '<operator>.addressOf' 
                           for sub_node in sub
                    ):
                        unknow_source['custom_function'][node] = node_dict[node]['code']+"  cv: "+cv
                        break
        # 若一个值修改语句都没有
        else:
            # 若关键变量在函数参数中
            if any(
                node_dict[sub_node]['_label'] == "METHOD_PARAMETER_IN"
                and cv == node_dict[sub_node]['name']
                for sub_node in ast.get_sub_ast(fid,node_dict)
            ):
                if cv not in unknow_source['function_parameter'][fid]:
                    unknow_source['function_parameter'][fid].append(cv)
            # 若不在函数参数中，若是结构体成员，则将该结构体加入 cv 中再进行匹配
            elif '->' in cv or '.' in cv:
                # 对于取结构体成员的情况，两者都加入。例子：对结构体初始化时，如 CVE-2014-0143-CWE-190-qemu-8f4754e-bdrv_create()-0.C
                tmp_cv_s = cv.split('->')[0].split('.')
                for tmp_cv in tmp_cv_s:
                    new_cv_line = tmp_cv + ":" + line
                    if new_cv_line not in cv_list:   # tmp_cv 是字符串类型
                        cv_list.append(new_cv_line)
            # 不是上面两种情况，则应该是全局变量
            else:
                unknow_source['global_variable'][fid] = cv

    source_dict = {}
    source_dict["good_source"] = good_source
    source_dict["unknow_source"] = unknow_source
    return source_dict, security_check    