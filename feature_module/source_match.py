from data_module.db_access import load_from_pickle
from graph_module import graph_class
from data_module.method_set import *

# 用作缓冲区溢出的安全检查
compare_operator = {
    "<operator>.greaterThan",
    "<operator>.greaterEqualsThan",
    "<operator>.lessThan",
    "<operator>.lessEqualsThan"
}

def security_check_OF(node, node_dict, ast, sub_ast, cv):
    """Buffer Overflow"""
    flag_compare = False
    flag_cv = False
    # cv需要出现在 if 语句中的比较语句中，比如&&和||连接的
    compare_statements = [] # 比较语句列表
    if node_dict[node]['_label'] == "CONTROL_STRUCTURE" and node_dict[node]['controlStructureType'] == "IF":
        for sub_node in sub_ast:
            # 将 sub_ast 分为以 && 和 || 连接的多个节点：都是比较语句
            if node_dict[sub_node]['_label'] == 'CALL' and node_dict[sub_node]['methodFullName'] in ('<operator>.logicalAnd', '<operator>.logicalOr'):
                # 若内部还有 && 和 || 连接，则去除自身，并将子节点加入
                if node in compare_statements:
                    compare_statements.remove(node)
                compare_statements += ast.edge_dict.get(node, [])
        if compare_statements == []:    # 没有通过 && 和 || 连接，则为自身
            compare_statements = [node]
        for state in compare_statements:
            # 对每个比较语句进行判断
            subs = ast.get_sub_ast(state, node_dict)
            for sub_node in subs:
                if node_dict[sub_node]['code'] == cv:
                    flag_cv = True
                if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name'] in compare_operator:
                    flag_compare = True
                if flag_cv and flag_compare:
                    return True
    # 通过min函数进行安全检查：index = min(a, len)。类似的 index = a > len ? len: a;
    flag_condition = flag_compare = False
    if node_dict[node]['_label'] == 'CALL' and node_dict[node]['name'] == "<operator>.assignment" and cv in node_dict[node]['code'].split('=')[0]:
        for sub_node in sub_ast:
            if node_dict[sub_node]['_label'] == 'CALL':
                # 若包含 min 函数
                if node_dict[sub_node]['methodFullName'] == 'min':
                    return True
                # 若包含 ?: 运算符且右侧是大小比较运算符
                if node_dict[sub_node]['methodFullName'] == '<operator>.conditional':
                    flag_condition = True
                if node_dict[sub_node]['name'] in compare_operator:
                    flag_compare = True
                if flag_condition and flag_compare:
                    return True
    return False

def security_check_NPD(node, node_dict, ast, sub_ast, cv):
    obj = node_dict[node]
    sub = ast.edge_dict.get(node, [])
    # strm = &strm1 
    if obj['_label'] == '<operator>.assignment' and node_dict[sub[-1]]['_label'] == 'CALL' and node_dict[sub[-1]]['methodFullName'] == '<operator>.addressOf':
        return True
    flag_null = False
    flag_cv = False
    if node_dict[node]['_label'] == "CONTROL_STRUCTURE" and node_dict[node]['controlStructureType'] == "IF":
        for sub_node in sub_ast:
            if node_dict[sub_node]['code'] == cv :
                flag_cv = True
            # if (!first)
            if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name']=="<operator>.logicalNot" :
                code = node_dict[sub_node]['code']
                if code.replace("!","") == cv:
                    return True
            # if (face == NULL)
            if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name']=="<operator>.equals" :
                code = node_dict[sub_node]['code'].split("==")
                if(
                    code[0].strip()==cv and code[1].strip()== "NULL"
                    or code[0].strip()== "NULL" and code[1].strip()== cv
                ):
                    return True
            # if (face)
            if len(sub_ast) == 2 :
                flag_null = True    
    if flag_cv and flag_null:
        return True
    return False

def security_check_DZ(node,node_dict,sub_ast, cv): 

    if node_dict[node]['_label'] == "CONTROL_STRUCTURE" and node_dict[node]['controlStructureType'] == "IF":
        for sub_node in sub_ast:

            # if(!num)
            if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name']=="<operator>.logicalNot" :
                code = node_dict[sub_node]['code']
                if code.replace("!","") == cv:
                    return True
                
            # if(num == 0)
            if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name']=="<operator>.equals" :
                code = node_dict[sub_node]['code'].split("==")
                if(code[0].strip()==cv and code[1].strip()== "0"):
                    return True

            # if(num<1)
            if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name']=="<operator>.lessthan" :
                code = node_dict[sub_node]['code'].split("<")
                if(code[0].strip()==cv and code[1].strip()== "1"):
                    return True
                
    return False

def match_source(
    fid, 
    node_dict, 
    graph_dict, 
    slice_result:list, 
    cv_s, 
    tp
):
    def compose_cv(node):
        if 'lineNumber' in node_dict[node]:
            return node_dict[node]['code'] + ":" + str(node_dict[node]['lineNumber'])
        else:
            return node_dict[node]['code'] + ":no lineNumber"
    slice_result.reverse()
    cv_list = []
    for cv in cv_s:
        if "lineNumber" in node_dict[slice_result[0]]: cv_list.append(cv+":"+str(node_dict[slice_result[0]]['lineNumber']))
        else: cv_list.append(cv+":"+"no lineNumber")
    good_source = {}
    unknow_source = {i: {} for i in ("custom_function", "function_parameter", "global_variable")}
    # 可能多个关键变量都是函数参数，因此需要写成一个列表
    unknow_source['function_parameter'][fid] = []
    security_check = {}
    ast = graph_dict[fid].ast
    for cv_line in cv_list:     # 之后都是放在 cv_list 的末尾的，并不会影响循环
        # 对每个关键变量
        line = cv_line.split(":")[1]
        cv = cv_line.split(":")[0]

        # 若某一个语句中存在值修改语句
        if any(
            # 必须是其前面的语句，免得结构体成员和外部成员名称相同。如 CVE-2014-0143-CWE-190-qemu-8f4754e-bdrv_create()-0.C
            "lineNumber" in node_dict[node] and line.isdigit() and node_dict[node]['lineNumber'] < int(line)
            and node_dict[node]['_label'] == 'CALL'
            and 
            # 赋值语句类型
            (node_dict[node]['name'] == "<operator>.assignment" 
            and cv == node_dict[ast.edge_dict.get(node, [])[0]]['code']     # 若赋值语句的左节点是 cv 才进行
            or 
            # 自定义函数的引用传递参数
            'operator' not in node_dict[node]['methodFullName']
            and node_dict[node]['methodFullName'] not in cfuns
            and any(cv == node_dict[sub_node]['code'].lstrip('&')
                    and "name" in node_dict[sub_node] and node_dict[sub_node]['name'] == '<operator>.addressOf' 
                    for sub_node in ast.get_sub_ast(node,node_dict)))
            for node in slice_result
        ):
            for node in slice_result:
                # 从下到上，对切片结果中的每一个语句节点
                if "lineNumber" in node_dict[node] and line.isdigit() and node_dict[node]['lineNumber'] >= int(line):   # 若在 cv 下方，不考虑
                    continue

                # 下面所需要的重要变量
                sub_ast = ast.get_sub_ast(node,node_dict)
                sub = ast.edge_dict.get(node, [])   # 直接相连的子节点
                obj = node_dict[node]

                # 判断当前语句是不是安全检查语句（根据类型）
                
                # 对于缓存区溢出和整数溢出，安全检查为比较大小
                if tp in ["AU","PU","FC","AE"]:
                    if(security_check_OF(node,node_dict, ast, sub_ast, cv)):
                        security_check[node] = node_dict[node]['code'] +"  cv: "+cv
                # 对于空指针解引用来说，安全检查为判断是否为空
                elif tp == "NPD":
                    if(security_check_NPD(node,node_dict, ast, sub_ast, cv)):
                        security_check[node] = node_dict[node]['code'] +"  cv: "+cv    
                elif tp == "DZ":
                    if(security_check_DZ(node,node_dict,sub_ast, cv)):
                        security_check[node] = node_dict[node]['code'] +"  cv: "+cv   
                
                # source 点匹配
                # 值修改语句：赋值语句
                if obj['_label'] == 'CALL' and obj['name'] == "<operator>.assignment":
                    right_node = sub[-1]
                    right_obj = node_dict[right_node]
                    right_ast = ast.get_sub_ast(right_node,node_dict)
                    right_sub = ast.edge_dict.get(right_node, [])
                    # 若左节点不是 cv 
                    if cv != node_dict[sub[0]]['code']:
                        # 例子： CVE-2014-0143-CWE-190-qemu-cab60de-expand_zero_clusters_in_l1()-0.c 的 FR
                        if right_obj['_label'] == 'CALL' and 'operator' not in right_obj['methodFullName'] and right_obj['methodFullName'] not in cfuns:
                            if any(cv in node_dict[sub_node]['code']
                                and "name" in node_dict[sub_node]
                                and node_dict[sub_node]['name'] == '<operator>.addressOf' 
                                for sub_node in right_ast
                            ):
                                unknow_source['custom_function'][node] = node_dict[node]['code']+"  cv: "+cv
                                break
                        continue
                    # 若赋值语句的左节点是 cv
                    # cow_header = (const void *)buf 情况，先去除类型转换，因下面多次使用到 right_node，也应将其换成后者
                    if right_obj['_label'] == 'CALL' and right_obj['methodFullName'] == '<operator>.cast':
                        right_node = right_sub[-1]
                        right_obj = node_dict[right_node]
                        right_sub = ast.edge_dict.get(right_node, [])
                    # cv = var, IDENTIFIER
                    if right_obj['_label'] == 'IDENTIFIER':
                        if compose_cv(right_node) not in cv_list:
                            cv_list.append(compose_cv(right_node))
                        break
                    # 若右侧都是常数，为 good_source
                    elif all(isConstant(node_dict[sub_node]) for sub_node in ast.get_sub_ast(right_node, node_dict)):
                        good_source[node] = node_dict[node]['code']+"  cv: "+cv
                        break
                    elif right_obj['_label'] == 'CALL':
                        right_leaves, custom_function_flag, custom_function_flag= ast.get_operator_separated_leaves(right_node, node_dict)
                        if custom_function_flag:
                            unknow_source['custom_function'][node] = node_dict[node]['code']+"  cv: "+cv
                            break
                        if custom_function_flag:
                            good_source[node] = node_dict[node]['code']+"  cv: "+cv
                        # if len(right_leaves) == 0:
                            # 就不break了，这只是一种可能性，不能准确。如果后面有新情况会覆盖它。
                            # unknow_source['custom_function'][node] = node_dict[node]['code']+"  cv: "+cv
                        # print([node_dict[i]['code'] for i in right_leaves])
                        if 'operator' not in right_obj['methodFullName']:
                            # 自定义函数赋值
                            if right_obj['methodFullName'] not in cfuns:
                                unknow_source['custom_function'][node] = node_dict[node]['code']+"  cv: "+cv
                                break
                            # C 库函数赋值
                            else:
                                # 根据类型判断当前语句中关键变量对应的是否为good_source
                                if (
                                    (tp in ["AU","PU","FC"]
                                    and any(node_dict[sub_node]['_label'] == "CALL" and "allc" in node_dict[sub_node]['name'] for sub_node in sub_ast))
                                    or
                                    # Free 类型，且 cv 和 NULL 都存在于节点之中
                                    (tp == "FR"
                                    and all(item in (node_dict[sub_node]['code'] for sub_node in sub_ast) for item in (cv, 'NULL') ))
                                ):
                                    good_source[node] = node_dict[node]['code']+"  cv: "+cv
                                else:
                                    cv_list.extend(compose_cv(i) for i in right_leaves if compose_cv(i) not in cv_list)
                                break
                        # 成员访问：a[i], a->b, a.b
                        elif right_obj['methodFullName'] in ('<operator>.indirectIndexAccess' , '<operator>.indirectFieldAccess', '<operator>.fieldAccess'):
                            cv_list.extend(compose_cv(i) for i in (right_node, right_sub[0]) if compose_cv(i) not in cv_list) # array[i], array
                            break
                        cv_list.extend(compose_cv(i) for i in right_leaves if compose_cv(i) not in cv_list)
                    else:
                        # 记录一下可能发生的其他情况
                        with open("log.txt","a") as l:
                            l.write(f"In assignment but not considered: \n\tnode: {node}, cv: {cv}, code: {node_dict[node]['code']}\n")
                        break
                # 值修改语句：自定义函数的引用传递的参数
                elif obj['_label'] == 'CALL' and 'operator' not in obj['methodFullName'] and obj['methodFullName'] not in cfuns:
                    if any(cv == node_dict[sub_node]['code'].lstrip('&')
                           and "name" in node_dict[sub_node]
                           and node_dict[sub_node]['name'] == '<operator>.addressOf' 
                           for sub_node in sub_ast
                    ):
                        unknow_source['custom_function'][node] = node_dict[node]['code']+"  cv: "+cv
                        break
        # 若一个值修改语句都没有
        else:
            # 若关键变量在函数参数中
            if any(
                node_dict[sub_node]['_label'] == "METHOD_PARAMETER_IN"
                and cv == node_dict[sub_node]['name']
                for sub_node in ast.get_sub_ast(fid,node_dict)
            ):
                if cv not in unknow_source['function_parameter'][fid]:
                    unknow_source['function_parameter'][fid].append(cv)
            # 若关键变量是局部定义的变量，也算good_source
            elif any(
                node_dict[node]['_label'] == "LOCAL"
                and cv == node_dict[node]['name']
                for node in slice_result
            ):
                for node in slice_result:
                    if node_dict[node]['_label'] == "LOCAL" and cv == node_dict[node]['name']:
                        good_source[node] = node_dict[node]['code']+"  cv: "+cv
            # 若不在函数参数和局部变量中，若是结构体成员，则将该结构体加入 cv 中再进行匹配
            elif '->' in cv or '.' in cv:
                # 对于取结构体成员的情况，两者都加入。例子：对结构体初始化时，如 CVE-2014-0143-CWE-190-qemu-8f4754e-bdrv_create()-0.C
                tmp_cv_s = cv.split('->')[0].split('.')
                for tmp_cv in tmp_cv_s:
                    new_cv_line = tmp_cv + ":" + line
                    if new_cv_line not in cv_list:   # tmp_cv 是字符串类型
                        cv_list.append(new_cv_line)
            # 不是上面几种情况，则应该是全局变量
            else:
                # 对于AU，我已经将其孩子放入了关键变量，若孩子找到了source，不认为它是全局变量
                if '[' in cv:
                    continue
                # if (tp == 'AU' and (
                #         len(good_source)
                #         or len(unknow_source['custom_function'])
                #         or len(unknow_source['function_parameter'][fid])
                #     )
                # ):
                    continue
                unknow_source['global_variable'][fid] = cv

    source_dict = {}
    source_dict["good_source"] = good_source
    source_dict["unknow_source"] = unknow_source
    return source_dict, security_check    