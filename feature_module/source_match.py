from data_module.db_access import load_from_pickle
from graph_module import graph_class

operator = ["<operator>.greaterThan","<operator>.greaterEqualsThan","<operator>.lessThan", "<operator>.lessEqualsThan"]
cfuns = load_from_pickle("feature_module/cfuns.db")

def cv_is_constant(node, node_dict, ast, cv):
    """ast为AST类型，sub_ast为node处的ast列表"""
    # 关键变量由常数赋值
    sub = ast.edge_dict.get(node, [])   # 直接相连的子节点
    if node_dict[node]['_label'] == "CALL" and node_dict[node]['name'] == "<operator>.assignment":
        if cv == node_dict[sub[0]]['code']: # 左节点
            # 若右节点的ast全部是常量（也包括如 myfunc(10, 20)这种），则为真
            if all(node_dict[sub_node]['_label'] == 'LITERAL' for sub_node in ast.get_sub_ast(sub[-1], node_dict)):
                return True
    return False


def exchange_cv(node,node_dict, sub_ast,cv,only_cv):
    cv_list = []
    # 赋值语句："first = face->charmaps" cv是“first”，返回“ face->charmaps”
    if node_dict[node]['_label'] == "CALL" and node_dict[node]['name'] == "<operator>.assignment":
        code = node_dict[node]['code'].split("=")
        if cv in code[0]:
            # print("assignment: ", node_dict[node]['code'])
            # 根据不同的赋值对象，获取转换后的关键变量
            
            # 赋值对象是普通变量
            if node_dict[sub_ast[2]]['_label'] == "IDENTIFIER" and node_dict[sub_ast[2]]['code'] not in only_cv:
                cv_list.append(node_dict[sub_ast[2]]['code']+":"+str(node_dict[sub_ast[2]]['lineNumber']))

            # 赋值对象是指针,加入“face->charmaps” 和“face”
            if node_dict[sub_ast[2]]['_label'] == "CALL" and node_dict[sub_ast[2]]['name'] =="<operator>.indirectFieldAccess" :
                if node_dict[sub_ast[2]]['code'] not in only_cv:
                    cv_list.append(node_dict[sub_ast[2]]['code']+":"+str(node_dict[sub_ast[2]]['lineNumber']))
                if(node_dict[sub_ast[3]]['_label'] == "IDENTIFIER") and node_dict[sub_ast[3]]['code'] not in only_cv:
                    cv_list.append(node_dict[sub_ast[3]]['code']+":"+str(node_dict[sub_ast[3]]['lineNumber']))

            # 赋值对象包含算数运算,加入所有的操作数
            if node_dict[sub_ast[2]]['_label'] == "CALL" and node_dict[sub_ast[2]]['name'] =="<operator>.addition" :
                cv_list.extend([node_dict[sub_node]['code']+":"+str(node_dict[sub_node]['lineNumber'])                           
                                    for sub_node in sub_ast[3:] if node_dict[sub_node]['_label'] == "IDENTIFIER" and  node_dict[sub_node]['code'] not in only_cv])
                
            # 赋值对象是函数，不转换cv，直接判断
                        

    # 控制语句，for循环，转换成上限

    if node_dict[node]['_label'] == "CASTForStatement":
        for sub_node in sub_ast:
            if node_dict[sub_node]['_label'] == "CALL" and node_dict[sub_node]['name'] in operator:
                cv_list.extend(node_dict[sub_node]['code'].split("<")[-1]+":"+str(node_dict[node]['lineNumber']))  

    
    return cv_list

            
def good_source_BOF(node, node_dict, sub_ast, cv):
    # malloc函数赋值的,关键变量是被赋值的变量
    if node_dict[node]['_label'] == "CALL" and node_dict[node]['name'] == "<operator>.assignment":
        if cv in node_dict[node]['code'].split("=")[0]:            
            for sub_node in sub_ast:
                if node_dict[sub_node]['_label']=="CALL" and "allc" in node_dict[sub_node]['name']: 
                    return True 
    return False   

def good_source_FR(node, node_dict, sub_ast, cv):
    # rdev->ena_pin = NULL; 关键变量赋值为NULL
    flag_null = False
    flag_cv = False
    if node_dict[node]['_label'] == "CALL" and node_dict[node]['name'] == "<operator>.assignment":
        for sub_node in sub_ast:
            if node_dict[sub_node]['code'] == cv :
                flag_cv = True
            if node_dict[sub_node]['code']=="NULL" :
                flag_null = True
    if flag_cv and flag_null:
        return True
    return False

def unknow_source_func(node, node_dict, ast, cv) -> bool:
    """情况一：是否由自定义函数赋值"""
    sub = ast.edge_dict.get(node, [])   # 直接相连的子节点
    if node_dict[node]['_label'] == "CALL" and node_dict[node]['name'] == "<operator>.assignment":  # 找到赋值类型的语句
        if cv == node_dict[sub[0]]['code']: # 左节点
            # 遍历右侧子节点的ast，若其中有自定义函数，则认为 unknown
            if any(node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name'] not in cfuns for sub_node in ast.get_sub_ast(sub[-1], node_dict)):
                return True
    return False

def security_check_OF(node, node_dict, ast, sub_ast, cv):
    """Buffer Overflow"""
    flag_compare = False
    flag_cv = False
    # cv需要出现在 if 语句中的比较语句中，比如&&和||连接的
    compare_statements = [] # 比较语句列表
    if node_dict[node]['_label'] == "CONTROL_STRUCTURE" and node_dict[node]['controlStructureType'] == "IF":
        for sub_node in sub_ast:
            # 将 sub_ast 分为以 && 和 || 连接的多个节点：都是比较语句
            if node_dict[sub_node]['_label'] == 'CALL' and node_dict[sub_node]['methodFullName'] in ('<operator>.logicalAnd', '<operator>.logicalOr'):
                # 若内部还有 && 和 || 连接，则去除自身，并将子节点加入
                if node in compare_statements:
                    compare_statements.remove(node)
                compare_statements += ast.edge_dict.get(node, [])
        if compare_statements == []:    # 没有通过 && 和 || 连接，则为自身
            compare_statements = [node]
        for state in compare_statements:
            # 对每个比较语句进行判断
            subs = ast.get_sub_ast(state, node_dict)
            for sub_node in subs:
                if node_dict[sub_node]['code'] == cv:
                    flag_cv = True
                if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name'] in operator:
                    flag_compare = True
                if flag_cv and flag_compare:
                    return True
    # 通过min函数进行安全检查：index = min(a, len)。类似的 index = a > len ? len: a;
    flag_condition = flag_compare = False
    if node_dict[node]['_label'] == 'CALL' and node_dict[node]['name'] == "<operator>.assignment" and cv in node_dict[node]['code'].split('=')[0]:
        for sub_node in sub_ast:
            if node_dict[sub_node]['_label'] == 'CALL':
                # 若包含 min 函数
                if node_dict[sub_node]['methodFullName'] == 'min':
                    return True
                # 若包含 ?: 运算符且右侧是大小比较运算符
                if node_dict[sub_node]['methodFullName'] == '<operator>.conditional':
                    flag_condition = True
                if node_dict[sub_node]['name'] in operator:
                    flag_compare = True
                if flag_condition and flag_compare:
                    return True
    return False

def security_check_NPD(node,node_dict,sub_ast, cv):
    flag_null = False
    flag_cv = False
    if node_dict[node]['_label'] == "CONTROL_STRUCTURE" and node_dict[node]['controlStructureType'] == "IF":
        for sub_node in sub_ast:
            if node_dict[sub_node]['code'] == cv :
                flag_cv = True
            # if (!first)
            if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name']=="<operator>.logicalNot" :
                code = node_dict[sub_node]['code']
                if code.replace("!","") == cv:
                    return True
            # if (face == NULL)
            if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name']=="<operator>.equals" :
                code = node_dict[sub_node]['code'].split("==")
                # print("code: ", code)
                if(code[0].strip()==cv and code[1].strip()== "NULL"):
                    return True
            # if (face)
            if len(sub_ast) == 2 :
                flag_null = True    
    if flag_cv and flag_null:
        return True
    return False

def security_check_DZ(node,node_dict,sub_ast, cv): 

    if node_dict[node]['_label'] == "CONTROL_STRUCTURE" and node_dict[node]['controlStructureType'] == "IF":
        for sub_node in sub_ast:

            # if(!num)
            if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name']=="<operator>.logicalNot" :
                code = node_dict[sub_node]['code']
                if code.replace("!","") == cv:
                    return True
                
            # if(num == 0)
            if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name']=="<operator>.equals" :
                code = node_dict[sub_node]['code'].split("==")
                if(code[0].strip()==cv and code[1].strip()== "0"):
                    return True

            # if(num<1)
            if node_dict[sub_node]['_label']=="CALL" and node_dict[sub_node]['name']=="<operator>.lessthan" :
                code = node_dict[sub_node]['code'].split("<")
                if(code[0].strip()==cv and code[1].strip()== "1"):
                    return True
                
    return False



# 在切片中根据sink点类型匹配是否存在对应的goodsource
# 从哪里获取关键变量？
# 变量转换语句如何进行变量转换函数
# 先匹配source点，再判断是否为good_source
# 通用的goodsource为常量
# 
def match_source(
    fid, 
    node_dict, 
    graph_dict, 
    slice_result:list, 
    cv_s, 
    tp
):
    # 从sink点向上遍历切片(直接从切片结果中倒序遍历就行)
    # 如何判断当前语句是否包含关键变量？子树中节点code一致
    # 判断当前切片节点是否为关键变量转化语句，如果是，转换关键变量
    # 并对获取到的新的关键变量，
    # 判断其是否为常数，如果是常数则为good_source
    # 如果是函数参数，则是unknow_source
    # 如果是自定义函数赋值，则是unknow_source
    # 判断当前语句是否为对应类型的good_source
    # 直到什么时候终止呢？匹配到good_source或者unknow_source,直到切片最上层
    slice_result.reverse()
    # print("slice: ", slice_result)
    # print("cv_s: ", cv_s)
    only_cv = set()
    cv_list = set()
    # cv是数组类型
    for cv in cv_s:
        only_cv.add(cv)
        cv_list.add(cv+":"+str(node_dict[slice_result[0]]['lineNumber']))

    
    good_source = {}
    unknow_source = {}
    security_check = {}
    try:
        for cv_line in cv_list:
            new_cv = []
            line = cv_line.split(":")[1]
            cv = cv_line.split(":")[0]
            
            for node in slice_result:
                if node_dict[node]['lineNumber'] > int(line): 
                    continue
                ast = graph_dict[fid].ast
                sub_ast = ast.get_sub_ast(node,node_dict)
                # 判断当前语句是不是关键变量转化语句,增加新的cv
                new_cv.extend(exchange_cv(node,node_dict, sub_ast,cv,only_cv))
                # 判断当前语句是不是安全检查语句（根据类型）
                # 对于缓存区溢出和整数溢出，安全检查为比较大小
                if tp in ["AU","PU","FC","AE"]:
                    if(security_check_OF(node,node_dict, ast, sub_ast, cv)):
                        security_check[node] = node_dict[node]['code'] +"  cv: "+cv
                # # 对于空指针解引用来说，安全检查为判断是否为空
                if tp == "NPD":
                    if(security_check_NPD(node,node_dict,sub_ast, cv)):
                        security_check[node] = node_dict[node]['code'] +"  cv: "+cv    
                if tp == "DZ":
                    if(security_check_DZ(node,node_dict,sub_ast, cv)):
                        security_check[node] = node_dict[node]['code'] +"  cv: "+cv   
                # 根据类型判断当前语句中关键变量对应的是否为good_source
                if tp in ["AU","PU","FC"]:
                    if(good_source_BOF(node, node_dict, sub_ast, cv)):
                        good_source[node] = node_dict[node]['code']+"  cv: "+cv
                        break
                if tp == "FR":
                    if(good_source_FR(node, node_dict, sub_ast, cv)):
                        good_source[node] = node_dict[node]['code']+"  cv: "+cv
                        break
                if(cv_is_constant(node, node_dict, ast, cv)):
                    good_source[node] = node_dict[node]['code']+"  cv: "+cv
                    break

                # 判断当前语句中关键变量是否由自定义函数赋值，若是则为unknow
                if(unknow_source_func(node, node_dict, ast, cv)):
                    unknow_source[node] = node_dict[node]['code']+"  cv: "+cv
                    break

            # cv没有任何新转化的cv，而且cv是函数参数，
            # 则为unknow_source，source点为函数头
            # print("new_cv: ", new_cv)
            if new_cv == []:
                cv_tmp = "-1"
                if '->' in cv:
                    cv_tmp = cv.split("->")[0]
                # 获取到函数参数列表
                sub_ast = graph_dict[fid].ast.get_sub_ast(fid,node_dict)
                for sub_node in sub_ast:
                    # 判断关键变量是否在这个列表中
                    if node_dict[sub_node]['_label'] == "METHOD_PARAMETER_IN":
                        if cv == node_dict[sub_node]['name'] or cv_tmp == node_dict[sub_node]['name']:
                            unknow_source[fid] = cv
            cv_list.update(new_cv)
    except RuntimeError as e:
        print(f"{e}: cv_list changed!\n")
    # print("!!!!!good_source: ",good_source) 
    # print("==================================")       
    # print("!!!!!unknow_source: ",unknow_source) 
    source_dict = {}
    source_dict["good_source"] = good_source
    source_dict["unknow_source"] = unknow_source
    return source_dict, security_check    